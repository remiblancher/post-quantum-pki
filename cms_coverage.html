
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cms: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/remiblancher/post-quantum-pki/internal/cms/decrypt.go (81.0%)</option>
				
				<option value="file1">github.com/remiblancher/post-quantum-pki/internal/cms/encrypt.go (82.1%)</option>
				
				<option value="file2">github.com/remiblancher/post-quantum-pki/internal/cms/enveloped.go (76.3%)</option>
				
				<option value="file3">github.com/remiblancher/post-quantum-pki/internal/cms/errors.go (100.0%)</option>
				
				<option value="file4">github.com/remiblancher/post-quantum-pki/internal/cms/parse.go (85.2%)</option>
				
				<option value="file5">github.com/remiblancher/post-quantum-pki/internal/cms/signed.go (92.7%)</option>
				
				<option value="file6">github.com/remiblancher/post-quantum-pki/internal/cms/signer.go (80.1%)</option>
				
				<option value="file7">github.com/remiblancher/post-quantum-pki/internal/cms/verify.go (79.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cms

import (
        "context"
        "crypto"
        "crypto/aes"
        "crypto/cipher"
        "crypto/ecdh"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rsa"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/asn1"
        "encoding/binary"
        "fmt"
        "hash"
        "io"

        "github.com/cloudflare/circl/kem"
        "github.com/cloudflare/circl/kem/mlkem/mlkem1024"
        "github.com/cloudflare/circl/kem/mlkem/mlkem512"
        "github.com/cloudflare/circl/kem/mlkem/mlkem768"
        "golang.org/x/crypto/hkdf"
)

// DecryptOptions configures CMS decryption.
type DecryptOptions struct {
        // PrivateKey is the recipient's private key for decryption.
        PrivateKey crypto.PrivateKey

        // Certificate is the recipient's certificate (optional, used for matching RecipientInfo).
        Certificate *x509.Certificate
}

// DecryptResult contains the decryption result.
type DecryptResult struct {
        // Content is the decrypted data.
        Content []byte

        // ContentType is the OID of the decrypted content.
        ContentType asn1.ObjectIdentifier
}

// Decrypt decrypts a CMS EnvelopedData or AuthEnvelopedData structure.
// It finds the matching RecipientInfo for the provided private key,
// decrypts the CEK, and then decrypts the content.
func Decrypt(ctx context.Context, data []byte, opts *DecryptOptions) (*DecryptResult, error) <span class="cov5" title="40">{
        _ = ctx // TODO: use for cancellation
        if opts == nil || opts.PrivateKey == nil </span><span class="cov3" title="8">{
                return nil, fmt.Errorf("private key is required")
        }</span>

        // Parse ContentInfo
        <span class="cov4" title="32">var ci ContentInfo
        rest, err := asn1.Unmarshal(data, &amp;ci)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse ContentInfo: %w", err)
        }</span>
        <span class="cov4" title="31">if len(rest) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("trailing data after ContentInfo")
        }</span>

        // Route based on content type
        <span class="cov4" title="31">if ci.ContentType.Equal(OIDAuthEnvelopedData) </span><span class="cov4" title="29">{
                return DecryptAuthEnveloped(ctx, ci.Content.Bytes, opts)
        }</span>

        <span class="cov1" title="2">if !ci.ContentType.Equal(OIDEnvelopedData) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not an EnvelopedData or AuthEnvelopedData: %v", ci.ContentType)
        }</span>

        // Parse EnvelopedData
        <span class="cov1" title="2">var env EnvelopedData
        if _, err := asn1.Unmarshal(ci.Content.Bytes, &amp;env); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse EnvelopedData: %w", err)
        }</span>

        // Find matching RecipientInfo and decrypt CEK
        <span class="cov1" title="2">cek, err := decryptCEK(&amp;env, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt CEK: %w", err)
        }</span>

        // Decrypt content
        <span class="cov1" title="2">content, err := decryptContent(&amp;env.EncryptedContentInfo, cek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt content: %w", err)
        }</span>

        <span class="cov1" title="2">return &amp;DecryptResult{
                Content:     content,
                ContentType: env.EncryptedContentInfo.ContentType,
        }, nil</span>
}

// DecryptAuthEnveloped decrypts a CMS AuthEnvelopedData structure (RFC 5083).
// For AES-GCM, the MAC field contains the authentication tag.
func DecryptAuthEnveloped(ctx context.Context, data []byte, opts *DecryptOptions) (*DecryptResult, error) <span class="cov4" title="29">{
        _ = ctx // TODO: use for cancellation
        if opts == nil || opts.PrivateKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("private key is required")
        }</span>

        // Parse AuthEnvelopedData
        <span class="cov4" title="29">var authEnv AuthEnvelopedData
        if _, err := asn1.Unmarshal(data, &amp;authEnv); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse AuthEnvelopedData: %w", err)
        }</span>

        // Find matching RecipientInfo and decrypt CEK
        <span class="cov4" title="29">cek, err := decryptCEKAuth(&amp;authEnv, opts)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to decrypt CEK: %w", err)
        }</span>

        // Decrypt content with MAC verification
        <span class="cov4" title="28">content, err := decryptContentAuth(&amp;authEnv, cek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt content: %w", err)
        }</span>

        <span class="cov4" title="28">return &amp;DecryptResult{
                Content:     content,
                ContentType: authEnv.AuthEncryptedContentInfo.ContentType,
        }, nil</span>
}

// decryptCEKAuth finds the matching RecipientInfo and decrypts the CEK for AuthEnvelopedData.
func decryptCEKAuth(authEnv *AuthEnvelopedData, opts *DecryptOptions) ([]byte, error) <span class="cov4" title="29">{
        for _, riRaw := range authEnv.RecipientInfos </span><span class="cov4" title="34">{
                cek, err := tryDecryptRecipientInfo(riRaw, opts)
                if err == nil </span><span class="cov4" title="28">{
                        return cek, nil
                }</span>
                // Continue trying other RecipientInfos
        }

        <span class="cov1" title="1">return nil, fmt.Errorf("no matching RecipientInfo found for provided key")</span>
}

// decryptContentAuth decrypts the content from AuthEnvelopedData with MAC verification.
// For AES-GCM, the MAC is the GCM authentication tag.
func decryptContentAuth(authEnv *AuthEnvelopedData, cek []byte) ([]byte, error) <span class="cov4" title="28">{
        alg := authEnv.AuthEncryptedContentInfo.ContentEncryptionAlgorithm.Algorithm

        if !alg.Equal(OIDAES256GCM) &amp;&amp; !alg.Equal(OIDAES128GCM) &amp;&amp; !alg.Equal(OIDAES192GCM) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AuthEnvelopedData requires AES-GCM, got: %v", alg)
        }</span>

        // Parse GCM parameters
        <span class="cov4" title="28">var params GCMParameters
        if _, err := asn1.Unmarshal(authEnv.AuthEncryptedContentInfo.ContentEncryptionAlgorithm.Parameters.FullBytes, &amp;params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse GCM parameters: %w", err)
        }</span>

        <span class="cov4" title="28">block, err := aes.NewCipher(cek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="28">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // For AuthEnvelopedData, the ciphertext and tag are stored separately:
        // - ciphertext in AuthEncryptedContentInfo.EncryptedContent
        // - tag in MAC field
        // GCM.Open expects ciphertext||tag, so we concatenate them
        <span class="cov4" title="28">ciphertextWithTag := append(authEnv.AuthEncryptedContentInfo.EncryptedContent, authEnv.MAC...)

        return gcm.Open(nil, params.Nonce, ciphertextWithTag, nil)</span>
}

// decryptCEK finds the matching RecipientInfo and decrypts the CEK.
func decryptCEK(env *EnvelopedData, opts *DecryptOptions) ([]byte, error) <span class="cov1" title="2">{
        for _, riRaw := range env.RecipientInfos </span><span class="cov1" title="2">{
                cek, err := tryDecryptRecipientInfo(riRaw, opts)
                if err == nil </span><span class="cov1" title="2">{
                        return cek, nil
                }</span>
                // Continue trying other RecipientInfos
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no matching RecipientInfo found for provided key")</span>
}

// tryDecryptRecipientInfo attempts to decrypt the CEK from a RecipientInfo.
func tryDecryptRecipientInfo(riRaw asn1.RawValue, opts *DecryptOptions) ([]byte, error) <span class="cov5" title="36">{
        // Determine RecipientInfo type by tag
        switch </span>{
        case riRaw.Tag == asn1.TagSequence &amp;&amp; riRaw.Class == asn1.ClassUniversal:<span class="cov4" title="20">
                // KeyTransRecipientInfo (SEQUENCE, no tag)
                // Use manual parsing to handle RecipientIdentifier CHOICE
                ktri, err := ParseKeyTransRecipientInfo(riRaw.FullBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="20">return decryptKeyTrans(ktri, opts)</span>

        case riRaw.Tag == 1 &amp;&amp; riRaw.Class == asn1.ClassContextSpecific:<span class="cov3" title="6">
                // [1] KeyAgreeRecipientInfo
                // Use manual parsing to handle KeyAgreeRecipientIdentifier CHOICE
                kari, err := ParseKeyAgreeRecipientInfo(riRaw.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="6">return decryptKeyAgree(kari, opts)</span>

        case riRaw.Tag == 4 &amp;&amp; riRaw.Class == asn1.ClassContextSpecific:<span class="cov3" title="10">
                // [4] OtherRecipientInfo - contains KEMRecipientInfo per RFC 9629
                // OtherRecipientInfo ::= SEQUENCE { oriType OID, oriValue ANY }
                kemri, err := parseOtherRecipientInfoKEM(riRaw.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="10">return decryptKEMRecipient(kemri, opts)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported RecipientInfo type: tag=%d, class=%d", riRaw.Tag, riRaw.Class)</span>
        }
}

// parseOtherRecipientInfoKEM parses OtherRecipientInfo containing KEMRecipientInfo.
// Per RFC 9629: OtherRecipientInfo ::= SEQUENCE { oriType OID, oriValue ANY }
func parseOtherRecipientInfoKEM(data []byte) (*KEMRecipientInfo, error) <span class="cov3" title="10">{
        remaining := data

        // Parse oriType OID
        var oriType asn1.ObjectIdentifier
        rest, err := asn1.Unmarshal(remaining, &amp;oriType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse oriType: %w", err)
        }</span>

        // Verify it's id-ori-kem
        <span class="cov3" title="10">if !oriType.Equal(OIDOriKEM) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported OtherRecipientInfo type: %v (expected id-ori-kem)", oriType)
        }</span>

        // Parse oriValue as KEMRecipientInfo SEQUENCE
        <span class="cov3" title="10">var oriValue asn1.RawValue
        _, err = asn1.Unmarshal(rest, &amp;oriValue)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse oriValue: %w", err)
        }</span>

        // oriValue should be a SEQUENCE containing KEMRecipientInfo
        <span class="cov3" title="10">if oriValue.Tag != asn1.TagSequence </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("oriValue is not a SEQUENCE: tag=%d", oriValue.Tag)
        }</span>

        // Parse the KEMRecipientInfo from the SEQUENCE bytes
        <span class="cov3" title="10">return ParseKEMRecipientInfo(oriValue.Bytes)</span>
}

// decryptKeyTrans decrypts the CEK from a KeyTransRecipientInfo (RSA).
func decryptKeyTrans(ktri *KeyTransRecipientInfo, opts *DecryptOptions) ([]byte, error) <span class="cov4" title="20">{
        rsaPriv, ok := opts.PrivateKey.(*rsa.PrivateKey)
        if !ok </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("RSA private key required for KeyTransRecipientInfo")
        }</span>

        // Check if RecipientIdentifier matches
        <span class="cov4" title="17">if opts.Certificate != nil &amp;&amp; ktri.RID.IssuerAndSerial != nil </span><span class="cov4" title="17">{
                if !matchesIssuerAndSerial(opts.Certificate, ktri.RID.IssuerAndSerial) </span><span class="cov1" title="2">{
                        return nil, fmt.Errorf("certificate does not match RecipientIdentifier")
                }</span>
        }

        // Determine decryption algorithm
        <span class="cov4" title="15">if ktri.KeyEncryptionAlgorithm.Algorithm.Equal(OIDRSAOAEP) </span><span class="cov4" title="15">{
                return rsa.DecryptOAEP(sha256.New(), nil, rsaPriv, ktri.EncryptedKey, nil)
        }</span> else<span class="cov0" title="0"> if ktri.KeyEncryptionAlgorithm.Algorithm.Equal(OIDRSAES) </span><span class="cov0" title="0">{
                return rsa.DecryptPKCS1v15(nil, rsaPriv, ktri.EncryptedKey)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported key encryption algorithm: %v", ktri.KeyEncryptionAlgorithm.Algorithm)</span>
}

// decryptKeyAgree decrypts the CEK from a KeyAgreeRecipientInfo (ECDH).
func decryptKeyAgree(kari *KeyAgreeRecipientInfo, opts *DecryptOptions) ([]byte, error) <span class="cov3" title="6">{
        ecdsaPriv, ok := opts.PrivateKey.(*ecdsa.PrivateKey)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("ECDSA private key required for KeyAgreeRecipientInfo")
        }</span>

        <span class="cov2" title="5">kdfHash, err := getKDFHashFunc(kari.KeyEncryptionAlgorithm.Algorithm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="5">ephPub, err := parseOriginatorPublicKey(kari.Originator, ecdsaPriv.Curve)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="5">kek, err := deriveKEKFromECDH(ecdsaPriv, ephPub, kari.KeyEncryptionAlgorithm, kdfHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="5">encryptedKey, err := findMatchingRecipientKey(kari.RecipientEncryptedKeys, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="5">return aesKeyUnwrap(kek, encryptedKey)</span>
}

// getKDFHashFunc returns the hash function for KDF based on key encryption algorithm OID.
func getKDFHashFunc(keaOID asn1.ObjectIdentifier) (func() hash.Hash, error) <span class="cov3" title="12">{
        switch </span>{
        case keaOID.Equal(OIDECDHStdSHA1KDF):<span class="cov1" title="1">
                return sha1.New, nil</span>
        case keaOID.Equal(OIDECDHStdSHA256KDF):<span class="cov3" title="6">
                return sha256.New, nil</span>
        case keaOID.Equal(OIDECDHStdSHA384KDF):<span class="cov1" title="1">
                return sha512.New384, nil</span>
        case keaOID.Equal(OIDECDHStdSHA512KDF):<span class="cov1" title="1">
                return sha512.New, nil</span>
        case keaOID.Equal(OIDAESWrap256), keaOID.Equal(OIDAESWrap128):<span class="cov1" title="2">
                return sha256.New, nil</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported key encryption algorithm: %v", keaOID)</span>
        }
}

// parseOriginatorPublicKey parses the ephemeral public key from Originator field.
func parseOriginatorPublicKey(originator asn1.RawValue, curve elliptic.Curve) (*ecdsa.PublicKey, error) <span class="cov2" title="5">{
        var originatorWrapper asn1.RawValue
        if _, err := asn1.Unmarshal(originator.Bytes, &amp;originatorWrapper); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse originator wrapper: %w", err)
        }</span>

        <span class="cov2" title="5">if originatorWrapper.Tag != 1 || originatorWrapper.Class != asn1.ClassContextSpecific </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected originatorKey [1], got tag=%d class=%d",
                        originatorWrapper.Tag, originatorWrapper.Class)
        }</span>

        <span class="cov2" title="5">originatorKeySeq, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      originatorWrapper.Bytes,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to reconstruct OriginatorPublicKey SEQUENCE: %w", err)
        }</span>

        <span class="cov2" title="5">var originatorKey OriginatorPublicKey
        if _, err := asn1.Unmarshal(originatorKeySeq, &amp;originatorKey); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse OriginatorPublicKey: %w", err)
        }</span>

        <span class="cov2" title="5">ephPub, err := parseECPublicKey(originatorKey.PublicKey.Bytes, curve)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse ephemeral public key: %w", err)
        }</span>
        <span class="cov2" title="5">return ephPub, nil</span>
}

// deriveKEKFromECDH computes the key encryption key using ECDH and KDF.
func deriveKEKFromECDH(ecdsaPriv *ecdsa.PrivateKey, ephPub *ecdsa.PublicKey, kea pkix.AlgorithmIdentifier, kdfHash func() hash.Hash) ([]byte, error) <span class="cov2" title="5">{
        sharedSecret, err := ecdhSharedSecretDecrypt(ecdsaPriv, ephPub)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ECDH failed: %w", err)
        }</span>

        <span class="cov2" title="5">wrapAlgBytes := getWrapAlgBytes(kea)
        sharedInfo, err := buildECCCMSSharedInfoDecryptRaw(wrapAlgBytes, 256)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build SharedInfo: %w", err)
        }</span>

        <span class="cov2" title="5">kek, err := ansix963KDFDecrypt(sharedSecret, 32, sharedInfo, kdfHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("KDF failed: %w", err)
        }</span>
        <span class="cov2" title="5">return kek, nil</span>
}

// getWrapAlgBytes extracts or builds the wrap algorithm bytes for SharedInfo.
func getWrapAlgBytes(kea pkix.AlgorithmIdentifier) []byte <span class="cov3" title="7">{
        if kea.Parameters.FullBytes != nil </span><span class="cov3" title="6">{
                return kea.Parameters.FullBytes
        }</span>
        <span class="cov1" title="1">nullParams, _ := asn1.Marshal(asn1.RawValue{Tag: asn1.TagNull})
        defaultAlg := pkix.AlgorithmIdentifier{
                Algorithm:  OIDAESWrap256,
                Parameters: asn1.RawValue{FullBytes: nullParams},
        }
        wrapAlgBytes, _ := asn1.Marshal(defaultAlg)
        return wrapAlgBytes</span>
}

// findMatchingRecipientKey finds the encrypted key for the matching recipient.
func findMatchingRecipientKey(reks []RecipientEncryptedKey, opts *DecryptOptions) ([]byte, error) <span class="cov3" title="7">{
        for _, rek := range reks </span><span class="cov3" title="7">{
                if opts.Certificate != nil &amp;&amp; rek.RID.IssuerAndSerial != nil </span><span class="cov3" title="7">{
                        if matchesIssuerAndSerial(opts.Certificate, rek.RID.IssuerAndSerial) </span><span class="cov3" title="6">{
                                return rek.EncryptedKey, nil
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }
                <span class="cov0" title="0">return rek.EncryptedKey, nil</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("no matching RecipientEncryptedKey found")</span>
}

// decryptKEMRecipient decrypts the CEK from a KEMRecipientInfo (ML-KEM).
func decryptKEMRecipient(kemri *KEMRecipientInfo, opts *DecryptOptions) ([]byte, error) <span class="cov3" title="10">{
        // Check if RecipientIdentifier matches
        if opts.Certificate != nil &amp;&amp; kemri.RID.IssuerAndSerial != nil </span><span class="cov3" title="8">{
                if !matchesIssuerAndSerial(opts.Certificate, kemri.RID.IssuerAndSerial) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("certificate does not match RecipientIdentifier")
                }</span>
        }

        // Determine ML-KEM scheme from OID and decapsulate
        <span class="cov3" title="10">var scheme kem.Scheme
        switch </span>{
        case kemri.KEM.Algorithm.Equal(OIDMLKEM512):<span class="cov1" title="2">
                scheme = mlkem512.Scheme()</span>
        case kemri.KEM.Algorithm.Equal(OIDMLKEM768):<span class="cov3" title="6">
                scheme = mlkem768.Scheme()</span>
        case kemri.KEM.Algorithm.Equal(OIDMLKEM1024):<span class="cov1" title="2">
                scheme = mlkem1024.Scheme()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported KEM algorithm: %v", kemri.KEM.Algorithm)</span>
        }

        // Unpack private key
        <span class="cov3" title="10">privKey, err := scheme.UnmarshalBinaryPrivateKey(getMLKEMPrivateKeyBytes(opts.PrivateKey))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal private key: %w", err)
        }</span>

        // KEM decapsulation
        <span class="cov3" title="10">sharedSecret, err := scheme.Decapsulate(privKey, kemri.KEMCT)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("KEM decapsulation failed: %w", err)
        }</span>

        // Build CMSORIforKEMOtherInfo for HKDF info parameter (RFC 9629 Section 6)
        <span class="cov3" title="10">kdfInfo, err := buildKEMKDFInfoDecrypt(kemri.Wrap, kemri.KEKLength, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build KDF info: %w", err)
        }</span>

        // Derive KEK from shared secret using HKDF with RFC 9629 info
        <span class="cov3" title="10">kek, err := deriveKEKFromECDHDecrypt(sharedSecret, kemri.KEKLength, kdfInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("KDF failed: %w", err)
        }</span>

        // Unwrap CEK
        <span class="cov3" title="10">return aesKeyUnwrap(kek, kemri.EncryptedKey)</span>
}

// decryptContent decrypts the encrypted content with the CEK.
func decryptContent(eci *EncryptedContentInfo, cek []byte) ([]byte, error) <span class="cov2" title="3">{
        alg := eci.ContentEncryptionAlgorithm.Algorithm

        switch </span>{
        case alg.Equal(OIDAES256GCM) || alg.Equal(OIDAES128GCM) || alg.Equal(OIDAES192GCM):<span class="cov0" title="0">
                return decryptAESGCM(eci, cek)</span>
        case alg.Equal(OIDAES256CBC) || alg.Equal(OIDAES128CBC) || alg.Equal(OIDAES192CBC):<span class="cov1" title="2">
                return decryptAESCBC(eci, cek)</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported content encryption algorithm: %v", alg)</span>
        }
}

// decryptAESGCM decrypts content encrypted with AES-GCM.
func decryptAESGCM(eci *EncryptedContentInfo, cek []byte) ([]byte, error) <span class="cov2" title="3">{
        // Parse GCM parameters
        var params GCMParameters
        if _, err := asn1.Unmarshal(eci.ContentEncryptionAlgorithm.Parameters.FullBytes, &amp;params); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse GCM parameters: %w", err)
        }</span>

        <span class="cov1" title="2">block, err := aes.NewCipher(cek)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return gcm.Open(nil, params.Nonce, eci.EncryptedContent, nil)</span>
}

// decryptAESCBC decrypts content encrypted with AES-CBC.
func decryptAESCBC(eci *EncryptedContentInfo, cek []byte) ([]byte, error) <span class="cov2" title="5">{
        // Parse IV from parameters
        var iv []byte
        if _, err := asn1.Unmarshal(eci.ContentEncryptionAlgorithm.Parameters.FullBytes, &amp;iv); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse IV: %w", err)
        }</span>

        <span class="cov2" title="5">if len(iv) != aes.BlockSize </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid IV length: %d", len(iv))
        }</span>

        <span class="cov2" title="4">block, err := aes.NewCipher(cek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="4">if len(eci.EncryptedContent)%aes.BlockSize != 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("ciphertext is not a multiple of block size")
        }</span>

        <span class="cov2" title="3">plaintext := make([]byte, len(eci.EncryptedContent))
        mode := cipher.NewCBCDecrypter(block, iv)
        mode.CryptBlocks(plaintext, eci.EncryptedContent)

        // Remove PKCS#7 padding
        if len(plaintext) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("plaintext is empty")
        }</span>
        <span class="cov2" title="3">padLen := int(plaintext[len(plaintext)-1])
        if padLen &gt; aes.BlockSize || padLen &gt; len(plaintext) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid padding")
        }</span>
        <span class="cov2" title="3">for i := len(plaintext) - padLen; i &lt; len(plaintext); i++ </span><span class="cov3" title="14">{
                if plaintext[i] != byte(padLen) </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("invalid PKCS#7 padding")
                }</span>
        }

        <span class="cov1" title="2">return plaintext[:len(plaintext)-padLen], nil</span>
}

// matchesIssuerAndSerial checks if a certificate matches an IssuerAndSerialNumber.
func matchesIssuerAndSerial(cert *x509.Certificate, ias *IssuerAndSerialNumber) bool <span class="cov4" title="35">{
        if cert.SerialNumber.Cmp(ias.SerialNumber) != 0 </span><span class="cov2" title="4">{
                return false
        }</span>
        // Compare raw issuer bytes
        <span class="cov4" title="31">return string(cert.RawIssuer) == string(ias.Issuer.FullBytes)</span>
}

// parseECPublicKey parses an uncompressed EC public key point.
func parseECPublicKey(data []byte, curve elliptic.Curve) (*ecdsa.PublicKey, error) <span class="cov3" title="7">{
        //nolint:staticcheck // elliptic.Unmarshal is deprecated but needed for X.509 compatibility
        x, y := elliptic.Unmarshal(curve, data)
        if x == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to unmarshal EC point")
        }</span>

        <span class="cov3" title="6">return &amp;ecdsa.PublicKey{
                Curve: curve,
                X:     x,
                Y:     y,
        }, nil</span>
}

// aesKeyUnwrap implements RFC 3394 AES Key Unwrap.
func aesKeyUnwrap(kek, ciphertext []byte) ([]byte, error) <span class="cov4" title="17">{
        if len(ciphertext) &lt; 24 || len(ciphertext)%8 != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ciphertext length")
        }</span>

        <span class="cov4" title="17">block, err := aes.NewCipher(kek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="17">n := (len(ciphertext) / 8) - 1
        a := make([]byte, 8)
        copy(a, ciphertext[:8])
        r := make([][]byte, n)
        for i := 0; i &lt; n; i++ </span><span class="cov5" title="66">{
                r[i] = make([]byte, 8)
                copy(r[i], ciphertext[8*(i+1):8*(i+2)])
        }</span>

        // Unwrap
        <span class="cov4" title="17">buf := make([]byte, 16)
        for j := 5; j &gt;= 0; j-- </span><span class="cov6" title="102">{
                for i := n; i &gt;= 1; i-- </span><span class="cov7" title="396">{
                        t := uint64(n*j + i)
                        // A ^= t
                        for k := 0; k &lt; 8; k++ </span><span class="cov10" title="3168">{
                                a[k] ^= byte(t &gt;&gt; (56 - 8*k))
                        }</span>
                        <span class="cov7" title="396">copy(buf[:8], a)
                        copy(buf[8:], r[i-1])
                        block.Decrypt(buf, buf)
                        copy(a, buf[:8])
                        copy(r[i-1], buf[8:])</span>
                }
        }

        // Check IV
        <span class="cov4" title="17">expectedIV := []byte{0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6}
        for i := 0; i &lt; 8; i++ </span><span class="cov6" title="129">{
                if a[i] != expectedIV[i] </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("key unwrap integrity check failed")
                }</span>
        }

        // Concatenate R blocks
        <span class="cov4" title="16">result := make([]byte, 0, n*8)
        for i := 0; i &lt; n; i++ </span><span class="cov5" title="62">{
                result = append(result, r[i]...)
        }</span>

        <span class="cov4" title="16">return result, nil</span>
}

// ecdhSharedSecretDecrypt computes ECDH shared secret for decryption.
func ecdhSharedSecretDecrypt(priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey) ([]byte, error) <span class="cov2" title="5">{
        ecdhPub, err := ecdsaToECDHDecrypt(pub)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="5">var curve ecdh.Curve
        switch priv.Curve </span>{
        case elliptic.P256():<span class="cov2" title="4">
                curve = ecdh.P256()</span>
        case elliptic.P384():<span class="cov1" title="1">
                curve = ecdh.P384()</span>
        case elliptic.P521():<span class="cov0" title="0">
                curve = ecdh.P521()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported curve")</span>
        }

        <span class="cov2" title="5">ecdhPriv, err := curve.NewPrivateKey(priv.D.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="5">return ecdhPriv.ECDH(ecdhPub)</span>
}

// ecdsaToECDHDecrypt converts an ECDSA public key to ECDH for decryption.
func ecdsaToECDHDecrypt(pub *ecdsa.PublicKey) (*ecdh.PublicKey, error) <span class="cov2" title="5">{
        var curve ecdh.Curve
        switch pub.Curve </span>{
        case elliptic.P256():<span class="cov2" title="4">
                curve = ecdh.P256()</span>
        case elliptic.P384():<span class="cov1" title="1">
                curve = ecdh.P384()</span>
        case elliptic.P521():<span class="cov0" title="0">
                curve = ecdh.P521()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported curve")</span>
        }

        // Build uncompressed point manually: 0x04 || X || Y
        // This avoids the deprecated elliptic.Marshal
        <span class="cov2" title="5">byteLen := (pub.Curve.Params().BitSize + 7) / 8
        pointBytes := make([]byte, 1+2*byteLen)
        pointBytes[0] = 0x04 // uncompressed point indicator
        pub.X.FillBytes(pointBytes[1 : 1+byteLen])
        pub.Y.FillBytes(pointBytes[1+byteLen:])
        return curve.NewPublicKey(pointBytes)</span>
}

// ansix963KDFDecrypt implements ANSI X9.63 KDF for decryption.
func ansix963KDFDecrypt(sharedSecret []byte, keySize int, sharedInfo []byte, h func() hash.Hash) ([]byte, error) <span class="cov2" title="5">{
        hashSize := h().Size()
        reps := (keySize + hashSize - 1) / hashSize

        var result []byte
        counter := make([]byte, 4)
        for i := 1; i &lt;= reps; i++ </span><span class="cov2" title="5">{
                binary.BigEndian.PutUint32(counter, uint32(i))
                hasher := h()
                hasher.Write(sharedSecret)
                hasher.Write(counter)
                if len(sharedInfo) &gt; 0 </span><span class="cov2" title="5">{
                        hasher.Write(sharedInfo)
                }</span>
                <span class="cov2" title="5">result = append(result, hasher.Sum(nil)...)</span>
        }

        <span class="cov2" title="5">return result[:keySize], nil</span>
}

// CMSORIforKEMOtherInfoDecrypt is the structure for HKDF info in KEMRecipientInfo (RFC 9629 Section 6).
type CMSORIforKEMOtherInfoDecrypt struct {
        Wrap      pkix.AlgorithmIdentifier
        KEKLength int
        // UKM is optional and omitted if nil
}

// buildKEMKDFInfoDecrypt builds the DER-encoded CMSORIforKEMOtherInfo for HKDF info (RFC 9629).
func buildKEMKDFInfoDecrypt(wrap pkix.AlgorithmIdentifier, kekLength int, ukm []byte) ([]byte, error) <span class="cov3" title="10">{
        info := CMSORIforKEMOtherInfoDecrypt{
                Wrap:      wrap,
                KEKLength: kekLength,
        }
        return asn1.Marshal(info)
}</span>

// deriveKEKFromECDHDecrypt derives a KEK from shared secret using HKDF for decryption.
func deriveKEKFromECDHDecrypt(sharedSecret []byte, keySize int, info []byte) ([]byte, error) <span class="cov3" title="10">{
        reader := hkdf.New(sha256.New, sharedSecret, nil, info)
        kek := make([]byte, keySize)
        if _, err := io.ReadFull(reader, kek); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="10">return kek, nil</span>
}

// getMLKEMPrivateKeyBytes extracts bytes from ML-KEM private key types.
func getMLKEMPrivateKeyBytes(priv crypto.PrivateKey) []byte <span class="cov3" title="10">{
        switch k := priv.(type) </span>{
        case *mlkem512.PrivateKey:<span class="cov1" title="2">
                b, _ := k.MarshalBinary()
                return b</span>
        case *mlkem768.PrivateKey:<span class="cov3" title="6">
                b, _ := k.MarshalBinary()
                return b</span>
        case *mlkem1024.PrivateKey:<span class="cov1" title="2">
                b, _ := k.MarshalBinary()
                return b</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// buildECCCMSSharedInfoDecryptRaw builds ECC-CMS-SharedInfo using raw keyInfo bytes.
// This is used for decryption to preserve the exact bytes from the CMS message,
// ensuring interoperability with different implementations (OpenSSL, BouncyCastle).
func buildECCCMSSharedInfoDecryptRaw(keyInfoBytes []byte, keyBits int) ([]byte, error) <span class="cov2" title="5">{
        // suppPubInfo: key length in bits as 4-byte big-endian in OCTET STRING
        // wrapped in [2] EXPLICIT
        keyLenBytes := make([]byte, 4)
        binary.BigEndian.PutUint32(keyLenBytes, uint32(keyBits))
        suppPubInfoOctetString, err := asn1.Marshal(keyLenBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal suppPubInfo octet string: %w", err)
        }</span>

        // Wrap suppPubInfo with [2] EXPLICIT tag
        <span class="cov2" title="5">suppPubInfoTagged, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassContextSpecific,
                Tag:        2,
                IsCompound: true,
                Bytes:      suppPubInfoOctetString,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal suppPubInfo tagged: %w", err)
        }</span>

        // Build complete ECC-CMS-SharedInfo SEQUENCE
        // Use the EXACT keyInfoBytes as-is (do not re-marshal)
        // IMPORTANT: Copy keyInfoBytes first! It may be a slice into a shared buffer
        // (e.g., the original CMS message), and append would corrupt subsequent data.
        <span class="cov2" title="5">seqContent := make([]byte, 0, len(keyInfoBytes)+len(suppPubInfoTagged))
        seqContent = append(seqContent, keyInfoBytes...)
        seqContent = append(seqContent, suppPubInfoTagged...)
        sharedInfo, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      seqContent,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal SharedInfo sequence: %w", err)
        }</span>

        <span class="cov2" title="5">return sharedInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cms

import (
        "context"
        "crypto"
        "crypto/aes"
        "crypto/cipher"
        "crypto/ecdh"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/asn1"
        "encoding/binary"
        "fmt"
        "hash"
        "io"

        "github.com/cloudflare/circl/kem"
        "github.com/cloudflare/circl/kem/mlkem/mlkem1024"
        "github.com/cloudflare/circl/kem/mlkem/mlkem512"
        "github.com/cloudflare/circl/kem/mlkem/mlkem768"
        "golang.org/x/crypto/hkdf"

        pkicrypto "github.com/remiblancher/post-quantum-pki/internal/crypto"
)

// EncryptOptions configures CMS encryption.
type EncryptOptions struct {
        // Recipients is the list of recipient certificates.
        // Each recipient will have their own RecipientInfo in the EnvelopedData.
        Recipients []*x509.Certificate

        // ContentType is the OID for the content being encrypted.
        // Defaults to id-data (1.2.840.113549.1.7.1).
        ContentType asn1.ObjectIdentifier

        // ContentEncryption specifies the content encryption algorithm.
        // Defaults to AES-256-GCM.
        ContentEncryption ContentEncryptionAlgorithm
}

// ContentEncryptionAlgorithm identifies the content encryption algorithm.
type ContentEncryptionAlgorithm int

const (
        // AES256GCM is AES-256 in GCM mode (recommended).
        AES256GCM ContentEncryptionAlgorithm = iota
        // AES256CBC is AES-256 in CBC mode (legacy compatibility).
        AES256CBC
        // AES128GCM is AES-128 in GCM mode.
        AES128GCM
)

// Encrypt creates a CMS EnvelopedData or AuthEnvelopedData structure.
// For AES-GCM, uses AuthEnvelopedData (RFC 5083) for OpenSSL compatibility.
// For AES-CBC, uses EnvelopedData (RFC 5652).
//
// The data is encrypted with a random CEK (Content Encryption Key),
// and the CEK is encrypted for each recipient using their public key.
//
// Supported recipient key types:
//   - RSA: Uses RSA-OAEP with SHA-256
//   - ECDSA/EC: Uses ECDH with ANSI X9.63 KDF and AES Key Wrap
//   - ML-KEM: Uses ML-KEM encapsulation with HKDF and AES Key Wrap
func Encrypt(ctx context.Context, data []byte, opts *EncryptOptions) ([]byte, error) <span class="cov4" title="32">{
        _ = ctx // TODO: use for cancellation
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;EncryptOptions{}
        }</span>

        // Route to AuthEnvelopedData for GCM algorithms
        <span class="cov4" title="32">switch opts.ContentEncryption </span>{
        case AES256GCM, AES128GCM:<span class="cov4" title="28">
                return EncryptAuthEnveloped(ctx, data, opts)</span>
        default:<span class="cov2" title="4">
                return encryptEnveloped(data, opts)</span>
        }
}

// EncryptAuthEnveloped creates a CMS AuthEnvelopedData structure (RFC 5083).
// Used for authenticated encryption (AES-GCM).
// The GCM authentication tag is stored in the MAC field.
func EncryptAuthEnveloped(ctx context.Context, data []byte, opts *EncryptOptions) ([]byte, error) <span class="cov4" title="28">{
        _ = ctx // TODO: use for cancellation
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;EncryptOptions{}
        }</span>

        <span class="cov4" title="28">if len(opts.Recipients) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("at least one recipient is required")
        }</span>

        <span class="cov4" title="27">contentType := opts.ContentType
        if contentType == nil </span><span class="cov4" title="26">{
                contentType = OIDData
        }</span>

        // Generate random CEK (Content Encryption Key)
        <span class="cov4" title="27">cekSize := 32 // AES-256
        if opts.ContentEncryption == AES128GCM </span><span class="cov2" title="3">{
                cekSize = 16
        }</span>
        <span class="cov4" title="27">cek := make([]byte, cekSize)
        if _, err := rand.Read(cek); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate CEK: %w", err)
        }</span>

        // Encrypt content with CEK using AES-GCM, returning ciphertext and tag separately
        <span class="cov4" title="27">ciphertext, tag, contentEncAlg, err := encryptAESGCMAuth(data, cek, opts.ContentEncryption)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt content: %w", err)
        }</span>

        // Create RecipientInfo for each recipient
        <span class="cov4" title="27">var recipientInfos []asn1.RawValue
        for _, cert := range opts.Recipients </span><span class="cov4" title="31">{
                ri, err := createRecipientInfo(cek, cert)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create recipient info for %s: %w", cert.Subject.CommonName, err)
                }</span>
                <span class="cov4" title="31">recipientInfos = append(recipientInfos, ri)</span>
        }

        // AuthEnvelopedData version is always 0
        // RFC 5083: "version is always 0"
        <span class="cov4" title="27">version := 0

        // Build AuthEnvelopedData
        authEnv := AuthEnvelopedData{
                Version:        version,
                RecipientInfos: recipientInfos,
                AuthEncryptedContentInfo: EncryptedContentInfo{
                        ContentType:                contentType,
                        ContentEncryptionAlgorithm: contentEncAlg,
                        EncryptedContent:           ciphertext,
                },
                MAC: tag, // GCM tag serves as the MAC
        }

        // Marshal AuthEnvelopedData
        authEnvBytes, err := asn1.Marshal(authEnv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal AuthEnvelopedData: %w", err)
        }</span>

        // Wrap in ContentInfo
        <span class="cov4" title="27">ci := ContentInfo{
                ContentType: OIDAuthEnvelopedData,
                Content: asn1.RawValue{
                        Class:      asn1.ClassContextSpecific,
                        Tag:        0,
                        IsCompound: true,
                        Bytes:      authEnvBytes,
                },
        }

        return asn1.Marshal(ci)</span>
}

// encryptAESGCMAuth encrypts data using AES-GCM and returns ciphertext and tag separately.
// This is used for AuthEnvelopedData where the tag is stored in the MAC field.
func encryptAESGCMAuth(data, cek []byte, alg ContentEncryptionAlgorithm) (ciphertext, tag []byte, algID pkix.AlgorithmIdentifier, err error) <span class="cov4" title="29">{
        block, err := aes.NewCipher(cek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov4" title="29">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov4" title="29">nonce := make([]byte, gcm.NonceSize())
        if _, err := rand.Read(nonce); err != nil </span><span class="cov0" title="0">{
                return nil, nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        // Seal returns ciphertext || tag
        <span class="cov4" title="29">sealed := gcm.Seal(nil, nonce, data, nil)

        // Split ciphertext and tag
        tagSize := gcm.Overhead()
        ciphertext = sealed[:len(sealed)-tagSize]
        tag = sealed[len(sealed)-tagSize:]

        // GCM parameters: nonce and tag length
        params := GCMParameters{
                Nonce:  nonce,
                ICVLen: tagSize,
        }
        paramsBytes, err := asn1.Marshal(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov4" title="29">var oid asn1.ObjectIdentifier
        if len(cek) == 32 </span><span class="cov4" title="25">{
                oid = OIDAES256GCM
        }</span> else<span class="cov2" title="4"> {
                oid = OIDAES128GCM
        }</span>

        <span class="cov4" title="29">algID = pkix.AlgorithmIdentifier{
                Algorithm:  oid,
                Parameters: asn1.RawValue{FullBytes: paramsBytes},
        }

        return ciphertext, tag, algID, nil</span>
}

// encryptEnveloped creates a CMS EnvelopedData structure (RFC 5652).
// Used for non-authenticated encryption (AES-CBC).
func encryptEnveloped(data []byte, opts *EncryptOptions) ([]byte, error) <span class="cov2" title="4">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;EncryptOptions{}
        }</span>

        <span class="cov2" title="4">if len(opts.Recipients) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("at least one recipient is required")
        }</span>

        <span class="cov2" title="4">contentType := opts.ContentType
        if contentType == nil </span><span class="cov2" title="4">{
                contentType = OIDData
        }</span>

        // Generate random CEK (Content Encryption Key)
        <span class="cov2" title="4">cekSize := 32 // AES-256
        if opts.ContentEncryption == AES128GCM </span><span class="cov0" title="0">{
                cekSize = 16
        }</span>
        <span class="cov2" title="4">cek := make([]byte, cekSize)
        if _, err := rand.Read(cek); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate CEK: %w", err)
        }</span>

        // Encrypt content with CEK
        <span class="cov2" title="4">encryptedContent, contentEncAlg, err := encryptContent(data, cek, opts.ContentEncryption)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt content: %w", err)
        }</span>

        // Create RecipientInfo for each recipient
        <span class="cov2" title="4">var recipientInfos []asn1.RawValue
        for _, cert := range opts.Recipients </span><span class="cov2" title="4">{
                ri, err := createRecipientInfo(cek, cert)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create recipient info for %s: %w", cert.Subject.CommonName, err)
                }</span>
                <span class="cov2" title="4">recipientInfos = append(recipientInfos, ri)</span>
        }

        // Determine EnvelopedData version per RFC 5652 Section 6.1
        // version 0: KeyTransRecipientInfo only
        // version 2: originatorInfo present, or KeyAgreeRecipientInfo [1]
        // version 3: pwri [3] or ori [4] (OtherRecipientInfo, including KEMRecipientInfo)
        <span class="cov2" title="4">version := 0
        for _, ri := range recipientInfos </span><span class="cov2" title="4">{
                // Check the tag from FullBytes first byte (context-specific tags)
                // 0xa0 = [0], 0xa1 = [1], 0xa2 = [2], 0xa3 = [3], 0xa4 = [4]
                tag := ri.Tag
                if len(ri.FullBytes) &gt; 0 </span><span class="cov2" title="4">{
                        firstByte := ri.FullBytes[0]
                        // Context-specific constructed: 0xa0-0xbf maps to tags 0-31
                        if firstByte &gt;= 0xa0 &amp;&amp; firstByte &lt;= 0xbf </span><span class="cov0" title="0">{
                                tag = int(firstByte &amp; 0x1f)
                        }</span>
                }
                <span class="cov2" title="4">if tag == 4 </span><span class="cov0" title="0">{ // OtherRecipientInfo (KEMRecipientInfo)
                        version = 3
                        break</span>
                }
                <span class="cov2" title="4">if tag == 1 </span><span class="cov0" title="0">{ // KeyAgreeRecipientInfo
                        version = 2
                }</span>
        }

        // Build EnvelopedData
        <span class="cov2" title="4">env := EnvelopedData{
                Version:        version,
                RecipientInfos: recipientInfos,
                EncryptedContentInfo: EncryptedContentInfo{
                        ContentType:                contentType,
                        ContentEncryptionAlgorithm: contentEncAlg,
                        EncryptedContent:           encryptedContent,
                },
        }

        // Marshal EnvelopedData
        envBytes, err := asn1.Marshal(env)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal EnvelopedData: %w", err)
        }</span>

        // Wrap in ContentInfo
        <span class="cov2" title="4">ci := ContentInfo{
                ContentType: OIDEnvelopedData,
                Content: asn1.RawValue{
                        Class:      asn1.ClassContextSpecific,
                        Tag:        0,
                        IsCompound: true,
                        Bytes:      envBytes,
                },
        }

        return asn1.Marshal(ci)</span>
}

// encryptContent encrypts the content with the CEK using the specified algorithm.
func encryptContent(data, cek []byte, alg ContentEncryptionAlgorithm) ([]byte, pkix.AlgorithmIdentifier, error) <span class="cov3" title="8">{
        switch alg </span>{
        case AES256GCM, AES128GCM:<span class="cov1" title="2">
                return encryptAESGCM(data, cek)</span>
        case AES256CBC:<span class="cov2" title="5">
                return encryptAESCBC(data, cek)</span>
        default:<span class="cov1" title="1">
                return encryptAESGCM(data, cek)</span>
        }
}

// encryptAESGCM encrypts data using AES-GCM.
func encryptAESGCM(data, cek []byte) ([]byte, pkix.AlgorithmIdentifier, error) <span class="cov3" title="6">{
        block, err := aes.NewCipher(cek)
        if err != nil </span><span class="cov1" title="1">{
                return nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov2" title="5">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov2" title="5">nonce := make([]byte, gcm.NonceSize())
        if _, err := rand.Read(nonce); err != nil </span><span class="cov0" title="0">{
                return nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov2" title="5">ciphertext := gcm.Seal(nil, nonce, data, nil)

        // GCM parameters: nonce and tag length
        params := GCMParameters{
                Nonce:  nonce,
                ICVLen: gcm.Overhead(),
        }
        paramsBytes, err := asn1.Marshal(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov2" title="5">var oid asn1.ObjectIdentifier
        if len(cek) == 32 </span><span class="cov2" title="3">{
                oid = OIDAES256GCM
        }</span> else<span class="cov1" title="2"> {
                oid = OIDAES128GCM
        }</span>

        <span class="cov2" title="5">algID := pkix.AlgorithmIdentifier{
                Algorithm:  oid,
                Parameters: asn1.RawValue{FullBytes: paramsBytes},
        }

        return ciphertext, algID, nil</span>
}

// encryptAESCBC encrypts data using AES-CBC with PKCS#7 padding.
func encryptAESCBC(data, cek []byte) ([]byte, pkix.AlgorithmIdentifier, error) <span class="cov3" title="6">{
        block, err := aes.NewCipher(cek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        // PKCS#7 padding
        <span class="cov3" title="6">padLen := aes.BlockSize - len(data)%aes.BlockSize
        padded := make([]byte, len(data)+padLen)
        copy(padded, data)
        for i := len(data); i &lt; len(padded); i++ </span><span class="cov5" title="42">{
                padded[i] = byte(padLen)
        }</span>

        // Generate random IV
        <span class="cov3" title="6">iv := make([]byte, aes.BlockSize)
        if _, err := rand.Read(iv); err != nil </span><span class="cov0" title="0">{
                return nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov3" title="6">ciphertext := make([]byte, len(padded))
        mode := cipher.NewCBCEncrypter(block, iv)
        mode.CryptBlocks(ciphertext, padded)

        // IV as parameters
        ivBytes, err := asn1.Marshal(iv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkix.AlgorithmIdentifier{}, err
        }</span>

        <span class="cov3" title="6">algID := pkix.AlgorithmIdentifier{
                Algorithm:  OIDAES256CBC,
                Parameters: asn1.RawValue{FullBytes: ivBytes},
        }

        return ciphertext, algID, nil</span>
}

// createRecipientInfo creates a RecipientInfo for a recipient certificate.
func createRecipientInfo(cek []byte, cert *x509.Certificate) (asn1.RawValue, error) <span class="cov4" title="35">{
        // Check for ML-KEM first (based on RawSubjectPublicKeyInfo OID)
        // This must be done before the type switch because the certificate
        // might have been created with a classical key and had its SPKI replaced.
        if isMLKEMCert(cert) </span><span class="cov3" title="10">{
                return createKEMRecipientInfo(cek, cert)
        }</span>

        <span class="cov4" title="25">switch pub := cert.PublicKey.(type) </span>{
        case *rsa.PublicKey:<span class="cov4" title="20">
                return createRSARecipientInfo(cek, cert, pub)</span>
        case *ecdsa.PublicKey:<span class="cov2" title="5">
                return createECDHRecipientInfo(cek, cert, pub)</span>
        default:<span class="cov0" title="0">
                return asn1.RawValue{}, fmt.Errorf("unsupported public key type: %T", pub)</span>
        }
}

// isMLKEMCert checks if the certificate contains an ML-KEM public key.
func isMLKEMCert(cert *x509.Certificate) bool <span class="cov5" title="40">{
        // Check the public key algorithm OID
        // This is a simplified check - in production, parse the SPKI properly
        raw := cert.RawSubjectPublicKeyInfo
        var spki struct {
                Algorithm pkix.AlgorithmIdentifier
                PublicKey asn1.BitString
        }
        if _, err := asn1.Unmarshal(raw, &amp;spki); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov5" title="40">return spki.Algorithm.Algorithm.Equal(OIDMLKEM512) ||
                spki.Algorithm.Algorithm.Equal(OIDMLKEM768) ||
                spki.Algorithm.Algorithm.Equal(OIDMLKEM1024)</span>
}

// getMLKEMAlgorithm returns the ML-KEM algorithm from a certificate.
func getMLKEMAlgorithm(cert *x509.Certificate) (pkicrypto.AlgorithmID, error) <span class="cov4" title="17">{
        raw := cert.RawSubjectPublicKeyInfo
        var spki struct {
                Algorithm pkix.AlgorithmIdentifier
                PublicKey asn1.BitString
        }
        if _, err := asn1.Unmarshal(raw, &amp;spki); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse SPKI: %w", err)
        }</span>

        <span class="cov4" title="17">switch </span>{
        case spki.Algorithm.Algorithm.Equal(OIDMLKEM512):<span class="cov2" title="4">
                return pkicrypto.AlgMLKEM512, nil</span>
        case spki.Algorithm.Algorithm.Equal(OIDMLKEM768):<span class="cov3" title="8">
                return pkicrypto.AlgMLKEM768, nil</span>
        case spki.Algorithm.Algorithm.Equal(OIDMLKEM1024):<span class="cov2" title="4">
                return pkicrypto.AlgMLKEM1024, nil</span>
        default:<span class="cov1" title="1">
                return "", fmt.Errorf("unknown ML-KEM algorithm OID: %v", spki.Algorithm.Algorithm)</span>
        }
}

// getMLKEMPublicKey extracts the ML-KEM public key from a certificate.
func getMLKEMPublicKey(cert *x509.Certificate) (crypto.PublicKey, pkicrypto.AlgorithmID, error) <span class="cov3" title="13">{
        raw := cert.RawSubjectPublicKeyInfo
        var spki struct {
                Algorithm pkix.AlgorithmIdentifier
                PublicKey asn1.BitString
        }
        if _, err := asn1.Unmarshal(raw, &amp;spki); err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to parse SPKI: %w", err)
        }</span>

        <span class="cov3" title="13">alg, err := getMLKEMAlgorithm(cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov3" title="13">pub, err := pkicrypto.ParseMLKEMPublicKey(alg, spki.PublicKey.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov3" title="13">return pub, alg, nil</span>
}

// createRSARecipientInfo creates a KeyTransRecipientInfo for RSA-OAEP.
func createRSARecipientInfo(cek []byte, cert *x509.Certificate, pub *rsa.PublicKey) (asn1.RawValue, error) <span class="cov4" title="20">{
        // Encrypt CEK with RSA-OAEP SHA-256
        encryptedKey, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, pub, cek, nil)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("RSA-OAEP encryption failed: %w", err)
        }</span>

        // RSA-OAEP parameters
        <span class="cov4" title="20">oaepParams := RSAOAEPParams{
                HashAlgorithm: pkix.AlgorithmIdentifier{
                        Algorithm: OIDSHA256,
                },
                MaskGenAlgorithm: pkix.AlgorithmIdentifier{
                        Algorithm: asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 8}, // id-mgf1
                },
        }
        oaepParamsBytes, err := asn1.Marshal(oaepParams)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, err
        }</span>

        <span class="cov4" title="20">ktri := KeyTransRecipientInfo{
                Version: 0,
                RID: RecipientIdentifier{
                        IssuerAndSerial: &amp;IssuerAndSerialNumber{
                                Issuer:       asn1.RawValue{FullBytes: cert.RawIssuer},
                                SerialNumber: cert.SerialNumber,
                        },
                },
                KeyEncryptionAlgorithm: pkix.AlgorithmIdentifier{
                        Algorithm:  OIDRSAOAEP,
                        Parameters: asn1.RawValue{FullBytes: oaepParamsBytes},
                },
                EncryptedKey: encryptedKey,
        }

        // Marshal using manual function to handle RecipientIdentifier CHOICE
        ktriBytes, err := MarshalKeyTransRecipientInfo(&amp;ktri)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, err
        }</span>

        <span class="cov4" title="20">return asn1.RawValue{FullBytes: ktriBytes}, nil</span>
}

// createECDHRecipientInfo creates a KeyAgreeRecipientInfo for ECDH.
func createECDHRecipientInfo(cek []byte, cert *x509.Certificate, pub *ecdsa.PublicKey) (asn1.RawValue, error) <span class="cov2" title="5">{
        // Generate ephemeral key pair
        ephPriv, err := ecdsa.GenerateKey(pub.Curve, rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("failed to generate ephemeral key: %w", err)
        }</span>

        // Compute shared secret
        <span class="cov2" title="5">sharedSecret, err := ecdhSharedSecret(ephPriv, pub)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("ECDH failed: %w", err)
        }</span>

        // Build ECC-CMS-SharedInfo for KDF (RFC 5753 Section 7.2)
        // ECC-CMS-SharedInfo ::= SEQUENCE {
        //   keyInfo AlgorithmIdentifier,
        //   entityUInfo [0] EXPLICIT OCTET STRING OPTIONAL,
        //   suppPubInfo [2] EXPLICIT OCTET STRING
        // }
        <span class="cov2" title="5">sharedInfo, err := buildECCCMSSharedInfo(OIDAESWrap256, 256)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("failed to build SharedInfo: %w", err)
        }</span>

        // Derive KEK using ANSI X9.63 KDF with SharedInfo
        <span class="cov2" title="5">kek, err := ansix963KDFSHA256(sharedSecret, 32, sharedInfo)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("KDF failed: %w", err)
        }</span>

        // Wrap CEK with KEK
        <span class="cov2" title="5">wrappedKey, err := aesKeyWrap(kek, cek)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("key wrap failed: %w", err)
        }</span>

        // Build OriginatorPublicKey
        <span class="cov2" title="5">var curveOID asn1.ObjectIdentifier
        switch pub.Curve </span>{
        case elliptic.P256():<span class="cov2" title="4">
                curveOID = asn1.ObjectIdentifier{1, 2, 840, 10045, 3, 1, 7}</span>
        case elliptic.P384():<span class="cov1" title="1">
                curveOID = asn1.ObjectIdentifier{1, 3, 132, 0, 34}</span>
        case elliptic.P521():<span class="cov0" title="0">
                curveOID = asn1.ObjectIdentifier{1, 3, 132, 0, 35}</span>
        default:<span class="cov0" title="0">
                return asn1.RawValue{}, fmt.Errorf("unsupported curve: %s", pub.Curve.Params().Name)</span>
        }

        <span class="cov2" title="5">curveOIDBytes, _ := asn1.Marshal(curveOID)

        //nolint:staticcheck // elliptic.Marshal is deprecated but needed for X.509 compatibility
        ephPubBytes := elliptic.Marshal(ephPriv.Curve, ephPriv.X, ephPriv.Y)

        originatorKey := OriginatorPublicKey{
                Algorithm: pkix.AlgorithmIdentifier{
                        Algorithm:  asn1.ObjectIdentifier{1, 2, 840, 10045, 2, 1}, // id-ecPublicKey
                        Parameters: asn1.RawValue{FullBytes: curveOIDBytes},
                },
                PublicKey: asn1.BitString{Bytes: ephPubBytes, BitLength: len(ephPubBytes) * 8},
        }

        // Marshal OriginatorPublicKey and apply [1] IMPLICIT tag correctly.
        // For IMPLICIT tagging, we replace the SEQUENCE tag with the context-specific tag.
        // We need to extract just the content from the SEQUENCE and wrap with [1].
        originatorKeyBytes, err := asn1.Marshal(originatorKey)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, err
        }</span>

        // Skip the SEQUENCE tag and length to get just the content.
        // originatorKeyBytes is: 0x30 &lt;length&gt; &lt;content&gt;
        // We need to extract &lt;content&gt; for IMPLICIT tagging.
        <span class="cov2" title="5">originatorKeyContent, err := extractASN1Content(originatorKeyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("failed to extract originatorKey content: %w", err)
        }</span>

        // Build [1] IMPLICIT OriginatorPublicKey
        <span class="cov2" title="5">originatorImplicit, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassContextSpecific,
                Tag:        1,
                IsCompound: true,
                Bytes:      originatorKeyContent,
        })
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, err
        }</span>

        // Build KeyEncryptionAlgorithm with ESDH scheme (RFC 5753)
        // dhSinglePass-stdDH-sha256kdf-scheme with KeyWrapAlgorithm as parameter
        // OpenSSL requires NULL parameters for AES key wrap algorithms for interoperability
        <span class="cov2" title="5">nullParams, _ := asn1.Marshal(asn1.RawValue{Tag: asn1.TagNull})
        wrapAlgBytes, err := asn1.Marshal(pkix.AlgorithmIdentifier{
                Algorithm:  OIDAESWrap256,
                Parameters: asn1.RawValue{FullBytes: nullParams},
        })
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("failed to marshal wrap algorithm: %w", err)
        }</span>

        <span class="cov2" title="5">kari := KeyAgreeRecipientInfo{
                Version: 3,
                Originator: asn1.RawValue{
                        FullBytes: originatorImplicit, // Use FullBytes so MarshalKeyAgreeRecipientInfo wraps with [0] EXPLICIT
                },
                KeyEncryptionAlgorithm: pkix.AlgorithmIdentifier{
                        Algorithm:  OIDECDHStdSHA256KDF, // dhSinglePass-stdDH-sha256kdf-scheme
                        Parameters: asn1.RawValue{FullBytes: wrapAlgBytes},
                },
                RecipientEncryptedKeys: []RecipientEncryptedKey{
                        {
                                RID: KeyAgreeRecipientIdentifier{
                                        IssuerAndSerial: &amp;IssuerAndSerialNumber{
                                                Issuer:       asn1.RawValue{FullBytes: cert.RawIssuer},
                                                SerialNumber: cert.SerialNumber,
                                        },
                                },
                                EncryptedKey: wrappedKey,
                        },
                },
        }

        // Use manual marshaling to handle KeyAgreeRecipientIdentifier CHOICE
        kariBytes, err := MarshalKeyAgreeRecipientInfo(&amp;kari)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, err
        }</span>

        <span class="cov2" title="5">return asn1.RawValue{FullBytes: kariBytes}, nil</span>
}

// createKEMRecipientInfo creates a KEMRecipientInfo for ML-KEM.
func createKEMRecipientInfo(cek []byte, cert *x509.Certificate) (asn1.RawValue, error) <span class="cov3" title="10">{
        // Get ML-KEM public key and algorithm from certificate
        pub, alg, err := getMLKEMPublicKey(cert)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, err
        }</span>

        // Get the appropriate scheme and perform KEM encapsulation
        <span class="cov3" title="10">var scheme kem.Scheme
        var kemOID asn1.ObjectIdentifier
        switch alg </span>{
        case pkicrypto.AlgMLKEM512:<span class="cov1" title="2">
                scheme = mlkem512.Scheme()
                kemOID = OIDMLKEM512</span>
        case pkicrypto.AlgMLKEM768:<span class="cov3" title="6">
                scheme = mlkem768.Scheme()
                kemOID = OIDMLKEM768</span>
        case pkicrypto.AlgMLKEM1024:<span class="cov1" title="2">
                scheme = mlkem1024.Scheme()
                kemOID = OIDMLKEM1024</span>
        default:<span class="cov0" title="0">
                return asn1.RawValue{}, fmt.Errorf("unsupported KEM algorithm: %s", alg)</span>
        }

        <span class="cov3" title="10">kemPub, ok := pub.(kem.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("invalid public key type for KEM: %T", pub)
        }</span>

        <span class="cov3" title="10">kemCT, sharedSecret, err := scheme.Encapsulate(kemPub)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("KEM encapsulation failed: %w", err)
        }</span>

        // Build wrap algorithm identifier for KDF info (RFC 9629)
        <span class="cov3" title="10">wrapAlg := pkix.AlgorithmIdentifier{Algorithm: OIDAESWrap256}

        // Build CMSORIforKEMOtherInfo for HKDF info parameter (RFC 9629 Section 6)
        kdfInfo, err := buildKEMKDFInfo(wrapAlg, 32, nil)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("failed to build KDF info: %w", err)
        }</span>

        // Derive KEK from shared secret using HKDF with RFC 9629 info
        <span class="cov3" title="10">kek, err := deriveKEK(sharedSecret, 32, kdfInfo)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("KDF failed: %w", err)
        }</span>

        // Wrap CEK with KEK
        <span class="cov3" title="10">wrappedKey, err := aesKeyWrap(kek, cek)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, fmt.Errorf("key wrap failed: %w", err)
        }</span>

        <span class="cov3" title="10">kemri := KEMRecipientInfo{
                Version: 0,
                RID: RecipientIdentifier{
                        IssuerAndSerial: &amp;IssuerAndSerialNumber{
                                Issuer:       asn1.RawValue{FullBytes: cert.RawIssuer},
                                SerialNumber: cert.SerialNumber,
                        },
                },
                KEM:          pkix.AlgorithmIdentifier{Algorithm: kemOID},
                KEMCT:        kemCT,
                KDF:          pkix.AlgorithmIdentifier{Algorithm: OIDHKDFSHA256},
                KEKLength:    32,
                Wrap:         wrapAlg,
                EncryptedKey: wrappedKey,
        }

        // Marshal with [2] IMPLICIT tag
        kemriBytes, err := MarshalKEMRecipientInfo(&amp;kemri)
        if err != nil </span><span class="cov0" title="0">{
                return asn1.RawValue{}, err
        }</span>

        <span class="cov3" title="10">return asn1.RawValue{FullBytes: kemriBytes}, nil</span>
}

// =============================================================================
// Helper functions for key wrap, KDF, and ECDH
// =============================================================================

// aesKeyWrap wraps a key using AES Key Wrap (RFC 3394).
func aesKeyWrap(kek, key []byte) ([]byte, error) <span class="cov4" title="19">{
        if len(key)%8 != 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("key length must be a multiple of 8 bytes")
        }</span>
        <span class="cov4" title="18">if len(key) &lt; 16 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("key must be at least 16 bytes")
        }</span>

        <span class="cov4" title="17">block, err := aes.NewCipher(kek)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create AES cipher: %w", err)
        }</span>

        <span class="cov4" title="17">n := len(key) / 8
        r := make([][]byte, n)
        for i := 0; i &lt; n; i++ </span><span class="cov5" title="66">{
                r[i] = make([]byte, 8)
                copy(r[i], key[i*8:(i+1)*8])
        }</span>

        // Default IV per RFC 3394
        <span class="cov4" title="17">a := []byte{0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6}

        for j := 0; j &lt; 6; j++ </span><span class="cov6" title="102">{
                for i := 1; i &lt;= n; i++ </span><span class="cov7" title="396">{
                        b := make([]byte, 16)
                        copy(b[:8], a)
                        copy(b[8:], r[i-1])

                        block.Encrypt(b, b)

                        t := uint64(n*j + i)
                        for k := 0; k &lt; 8; k++ </span><span class="cov10" title="3168">{
                                b[k] ^= byte(t &gt;&gt; (56 - 8*k))
                        }</span>

                        <span class="cov7" title="396">copy(a, b[:8])
                        copy(r[i-1], b[8:])</span>
                }
        }

        // Output: A || R[1] || R[2] || ... || R[n]
        <span class="cov4" title="17">out := make([]byte, 8+len(key))
        copy(out[:8], a)
        for i := 0; i &lt; n; i++ </span><span class="cov5" title="66">{
                copy(out[8+i*8:], r[i])
        }</span>

        <span class="cov4" title="17">return out, nil</span>
}

// ecdhSharedSecret computes the ECDH shared secret between a private key and a public key.
func ecdhSharedSecret(priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey) ([]byte, error) <span class="cov3" title="9">{
        // Convert ecdsa keys to ecdh keys
        privECDH, err := priv.ECDH()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert private key to ECDH: %w", err)
        }</span>

        <span class="cov3" title="9">pubECDH, err := ecdsaToECDH(pub)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert public key to ECDH: %w", err)
        }</span>

        <span class="cov3" title="9">return privECDH.ECDH(pubECDH)</span>
}

// ecdsaToECDH converts an ecdsa.PublicKey to an ecdh.PublicKey.
func ecdsaToECDH(pub *ecdsa.PublicKey) (*ecdh.PublicKey, error) <span class="cov3" title="12">{
        var curve ecdh.Curve
        switch pub.Curve.Params().Name </span>{
        case "P-256":<span class="cov3" title="7">
                curve = ecdh.P256()</span>
        case "P-384":<span class="cov2" title="4">
                curve = ecdh.P384()</span>
        case "P-521":<span class="cov1" title="1">
                curve = ecdh.P521()</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported curve: %s", pub.Curve.Params().Name)</span>
        }

        // Marshal the public key point to uncompressed format
        <span class="cov3" title="12">rawPub := ecMarshalUncompressed(pub)

        return curve.NewPublicKey(rawPub)</span>
}

// ecMarshalUncompressed marshals an EC public key to uncompressed format.
func ecMarshalUncompressed(pub *ecdsa.PublicKey) []byte <span class="cov4" title="15">{
        byteLen := (pub.Curve.Params().BitSize + 7) / 8
        ret := make([]byte, 1+2*byteLen)
        ret[0] = 4 // uncompressed point
        pub.X.FillBytes(ret[1 : 1+byteLen])
        pub.Y.FillBytes(ret[1+byteLen : 1+2*byteLen])
        return ret
}</span>

// CMSORIforKEMOtherInfo is the structure for HKDF info in KEMRecipientInfo (RFC 9629 Section 6).
// CMSORIforKEMOtherInfo ::= SEQUENCE {
//
//        wrap       KeyEncryptionAlgorithmIdentifier,
//        kekLength  INTEGER,
//        ukm        [0] EXPLICIT OtherKeyAttribute OPTIONAL
//
// }
type CMSORIforKEMOtherInfo struct {
        Wrap      pkix.AlgorithmIdentifier
        KEKLength int
        // UKM is optional and omitted if nil
}

// buildKEMKDFInfo builds the DER-encoded CMSORIforKEMOtherInfo for HKDF info (RFC 9629).
func buildKEMKDFInfo(wrap pkix.AlgorithmIdentifier, kekLength int, ukm []byte) ([]byte, error) <span class="cov3" title="11">{
        info := CMSORIforKEMOtherInfo{
                Wrap:      wrap,
                KEKLength: kekLength,
        }
        // Note: UKM (user keying material) is not included in this implementation
        return asn1.Marshal(info)
}</span>

// deriveKEK derives a Key Encryption Key from shared secret using HKDF.
func deriveKEK(sharedSecret []byte, keySize int, info []byte) ([]byte, error) <span class="cov3" title="14">{
        kdf := hkdf.New(sha256.New, sharedSecret, nil, info)
        kek := make([]byte, keySize)
        if _, err := io.ReadFull(kdf, kek); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HKDF failed: %w", err)
        }</span>
        <span class="cov3" title="14">return kek, nil</span>
}

// ansix963KDF derives a key using ANSI X9.63 KDF (used with ECDH in CMS).
func ansix963KDF(sharedSecret []byte, keySize int, sharedInfo []byte, h func() hash.Hash) ([]byte, error) <span class="cov3" title="11">{
        hashLen := h().Size()
        reps := (keySize + hashLen - 1) / hashLen

        var result []byte
        counter := uint32(1)

        for i := 0; i &lt; reps; i++ </span><span class="cov3" title="12">{
                hasher := h()
                hasher.Write(sharedSecret)

                // Counter as big-endian 32-bit
                var counterBytes [4]byte
                binary.BigEndian.PutUint32(counterBytes[:], counter)
                hasher.Write(counterBytes[:])

                if len(sharedInfo) &gt; 0 </span><span class="cov3" title="12">{
                        hasher.Write(sharedInfo)
                }</span>

                <span class="cov3" title="12">result = append(result, hasher.Sum(nil)...)
                counter++</span>
        }

        <span class="cov3" title="11">return result[:keySize], nil</span>
}

// ansix963KDFSHA256 is a convenience wrapper for ANSI X9.63 KDF with SHA-256.
func ansix963KDFSHA256(sharedSecret []byte, keySize int, sharedInfo []byte) ([]byte, error) <span class="cov3" title="8">{
        return ansix963KDF(sharedSecret, keySize, sharedInfo, sha256.New)
}</span>

// buildECCCMSSharedInfo builds the ECC-CMS-SharedInfo structure for KDF (RFC 5753).
// ECC-CMS-SharedInfo ::= SEQUENCE {
//
//        keyInfo AlgorithmIdentifier,
//        entityUInfo [0] EXPLICIT OCTET STRING OPTIONAL,
//        suppPubInfo [2] EXPLICIT OCTET STRING
//
// }
// suppPubInfo contains the key length in bits as a 4-byte big-endian integer.
func buildECCCMSSharedInfo(wrapAlgOID asn1.ObjectIdentifier, keyBits int) ([]byte, error) <span class="cov3" title="7">{
        // keyInfo: AlgorithmIdentifier for wrap algorithm
        // OpenSSL requires NULL parameters for AES key wrap algorithms.
        // This MUST match what's in KeyEncryptionAlgorithm.parameters in the CMS message.
        nullParams, _ := asn1.Marshal(asn1.RawValue{Tag: asn1.TagNull})
        keyInfo := pkix.AlgorithmIdentifier{
                Algorithm:  wrapAlgOID,
                Parameters: asn1.RawValue{FullBytes: nullParams},
        }
        keyInfoBytes, err := asn1.Marshal(keyInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal keyInfo: %w", err)
        }</span>

        // suppPubInfo: key length in bits as 4-byte big-endian in OCTET STRING
        // wrapped in [2] EXPLICIT
        <span class="cov3" title="7">keyLenBytes := make([]byte, 4)
        binary.BigEndian.PutUint32(keyLenBytes, uint32(keyBits))
        suppPubInfoOctetString, err := asn1.Marshal(keyLenBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal suppPubInfo octet string: %w", err)
        }</span>

        // Wrap suppPubInfo with [2] EXPLICIT tag
        <span class="cov3" title="7">suppPubInfoTagged, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassContextSpecific,
                Tag:        2,
                IsCompound: true,
                Bytes:      suppPubInfoOctetString,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal suppPubInfo tagged: %w", err)
        }</span>

        // Build complete ECC-CMS-SharedInfo SEQUENCE
        // RFC 5753: "the ECC-CMS-SharedInfo value ... is DER encoded and passed
        // as SharedInfo to the X9.63 KDF"
        <span class="cov3" title="7">seqContent := append(keyInfoBytes, suppPubInfoTagged...)
        sharedInfo, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      seqContent,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal SharedInfo sequence: %w", err)
        }</span>

        <span class="cov3" title="7">return sharedInfo, nil</span>
}

// extractASN1Content extracts the content from a DER-encoded ASN.1 value,
// skipping the tag and length bytes. This is used for IMPLICIT tagging
// where we need to replace the original tag with a context-specific tag.
func extractASN1Content(der []byte) ([]byte, error) <span class="cov3" title="10">{
        if len(der) &lt; 2 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("DER too short")
        }</span>

        // Skip tag byte
        <span class="cov3" title="9">pos := 1

        // Parse length
        length := int(der[pos])
        pos++

        if length &lt; 128 </span><span class="cov3" title="6">{
                // Short form: length is directly encoded
                return der[pos:], nil
        }</span>

        // Long form: first byte indicates number of length bytes
        <span class="cov2" title="3">numLenBytes := length &amp; 0x7f
        if len(der) &lt; pos+numLenBytes </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("DER truncated in length field")
        }</span>

        // Skip length bytes
        <span class="cov1" title="2">pos += numLenBytes

        return der[pos:], nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cms

import (
        "crypto/x509/pkix"
        "encoding/asn1"
        "fmt"
        "math/big"
)

// EnvelopedData represents CMS EnvelopedData (RFC 5652 Section 6).
//
//        EnvelopedData ::= SEQUENCE {
//          version CMSVersion,
//          originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
//          recipientInfos RecipientInfos,
//          encryptedContentInfo EncryptedContentInfo,
//          unprotectedAttrs [1] IMPLICIT UnprotectedAttributes OPTIONAL }
type EnvelopedData struct {
        Version              int
        OriginatorInfo       asn1.RawValue   `asn1:"optional,tag:0"`
        RecipientInfos       []asn1.RawValue `asn1:"set"`
        EncryptedContentInfo EncryptedContentInfo
        UnprotectedAttrs     []Attribute `asn1:"optional,set,tag:1"`
}

// AuthEnvelopedData represents CMS AuthEnvelopedData (RFC 5083).
// Used for authenticated encryption (AES-GCM).
//
//        AuthEnvelopedData ::= SEQUENCE {
//          version CMSVersion,
//          originatorInfo [0] IMPLICIT OriginatorInfo OPTIONAL,
//          recipientInfos RecipientInfos,
//          authEncryptedContentInfo EncryptedContentInfo,
//          authAttrs [1] IMPLICIT AuthAttributes OPTIONAL,
//          mac MessageAuthenticationCode,
//          unauthAttrs [2] IMPLICIT UnauthAttributes OPTIONAL }
type AuthEnvelopedData struct {
        Version                  int
        OriginatorInfo           asn1.RawValue   `asn1:"optional,tag:0"`
        RecipientInfos           []asn1.RawValue `asn1:"set"`
        AuthEncryptedContentInfo EncryptedContentInfo
        AuthAttrs                []Attribute `asn1:"optional,set,tag:1"`
        MAC                      []byte
        UnauthAttrs              []Attribute `asn1:"optional,set,tag:2"`
}

// EncryptedContentInfo contains the encrypted content (RFC 5652 Section 6.1).
//
//        EncryptedContentInfo ::= SEQUENCE {
//          contentType ContentType,
//          contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,
//          encryptedContent [0] IMPLICIT EncryptedContent OPTIONAL }
type EncryptedContentInfo struct {
        ContentType                asn1.ObjectIdentifier
        ContentEncryptionAlgorithm pkix.AlgorithmIdentifier
        EncryptedContent           []byte `asn1:"optional,tag:0"`
}

// RecipientInfo is the CHOICE for different key management techniques.
// We handle it as RawValue and parse based on tag.
//
//        RecipientInfo ::= CHOICE {
//          ktri KeyTransRecipientInfo,
//          kari [1] KeyAgreeRecipientInfo,
//          kekri [2] KEKRecipientInfo,
//          pwri [3] PasswordRecipientInfo,
//          ori [4] OtherRecipientInfo }

// KeyTransRecipientInfo for RSA key transport (RFC 5652 Section 6.2.1).
//
//        KeyTransRecipientInfo ::= SEQUENCE {
//          version CMSVersion,  -- always set to 0 or 2
//          rid RecipientIdentifier,
//          keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
//          encryptedKey EncryptedKey }
type KeyTransRecipientInfo struct {
        Version                int
        RID                    RecipientIdentifier
        KeyEncryptionAlgorithm pkix.AlgorithmIdentifier
        EncryptedKey           []byte
}

// RecipientIdentifier identifies the recipient's certificate.
//
//        RecipientIdentifier ::= CHOICE {
//          issuerAndSerialNumber IssuerAndSerialNumber,
//          subjectKeyIdentifier [0] SubjectKeyIdentifier }
//
// Note: This is stored as RawValue because Go's encoding/asn1 cannot
// automatically handle CHOICE types. Use the helper methods to access.
type RecipientIdentifier struct {
        IssuerAndSerial *IssuerAndSerialNumber
        SKI             []byte `asn1:"optional,tag:0"`
}

// Marshal encodes RecipientIdentifier as ASN.1 DER.
// This handles the ASN.1 CHOICE by marshaling only the present alternative.
// Go's encoding/asn1 cannot automatically handle CHOICE types.
func (rid RecipientIdentifier) Marshal() ([]byte, error) <span class="cov9" title="26">{
        if rid.IssuerAndSerial != nil </span><span class="cov8" title="23">{
                // Marshal IssuerAndSerialNumber directly (no SEQUENCE wrapper needed,
                // IssuerAndSerialNumber is already a SEQUENCE)
                return asn1.Marshal(*rid.IssuerAndSerial)
        }</span>
        <span class="cov3" title="3">if rid.SKI != nil </span><span class="cov2" title="2">{
                // Marshal as [0] IMPLICIT OCTET STRING
                return asn1.Marshal(asn1.RawValue{
                        Class:      asn1.ClassContextSpecific,
                        Tag:        0,
                        IsCompound: false,
                        Bytes:      rid.SKI,
                })
        }</span>
        <span class="cov1" title="1">return nil, asn1.StructuralError{Msg: "empty RecipientIdentifier: neither IssuerAndSerial nor SKI set"}</span>
}

// ParseRecipientIdentifier parses a RecipientIdentifier from ASN.1 DER.
func ParseRecipientIdentifier(data []byte) (RecipientIdentifier, []byte, error) <span class="cov10" title="39">{
        var raw asn1.RawValue
        rest, err := asn1.Unmarshal(data, &amp;raw)
        if err != nil </span><span class="cov3" title="3">{
                return RecipientIdentifier{}, nil, err
        }</span>

        <span class="cov9" title="36">var rid RecipientIdentifier
        if raw.Tag == 0 &amp;&amp; raw.Class == asn1.ClassContextSpecific </span><span class="cov2" title="2">{
                // SubjectKeyIdentifier [0]
                rid.SKI = raw.Bytes
        }</span> else<span class="cov9" title="34"> if raw.Tag == asn1.TagSequence &amp;&amp; raw.Class == asn1.ClassUniversal </span><span class="cov9" title="34">{
                // IssuerAndSerialNumber (SEQUENCE)
                var ias IssuerAndSerialNumber
                if _, err := asn1.Unmarshal(raw.FullBytes, &amp;ias); err != nil </span><span class="cov1" title="1">{
                        return RecipientIdentifier{}, nil, err
                }</span>
                <span class="cov9" title="33">rid.IssuerAndSerial = &amp;ias</span>
        } else<span class="cov0" title="0"> {
                return RecipientIdentifier{}, nil, asn1.StructuralError{
                        Msg: fmt.Sprintf("invalid RecipientIdentifier: tag=%d, class=%d", raw.Tag, raw.Class),
                }
        }</span>

        <span class="cov9" title="35">return rid, rest, nil</span>
}

// ParseKeyTransRecipientInfo parses a KeyTransRecipientInfo from ASN.1 DER.
// This handles the RecipientIdentifier CHOICE manually since Go's encoding/asn1
// cannot automatically handle CHOICE types with pointers.
func ParseKeyTransRecipientInfo(data []byte) (*KeyTransRecipientInfo, error) <span class="cov8" title="24">{
        // Parse outer SEQUENCE
        var raw asn1.RawValue
        if _, err := asn1.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse KTRI outer: %w", err)
        }</span>
        <span class="cov8" title="24">if raw.Tag != asn1.TagSequence </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected SEQUENCE, got tag %d", raw.Tag)
        }</span>

        <span class="cov8" title="24">remaining := raw.Bytes
        ktri := &amp;KeyTransRecipientInfo{}

        // Parse version INTEGER
        var version int
        rest, err := asn1.Unmarshal(remaining, &amp;version)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse version: %w", err)
        }</span>
        <span class="cov8" title="23">ktri.Version = version
        remaining = rest

        // Parse RecipientIdentifier (CHOICE)
        rid, rest, err := ParseRecipientIdentifier(remaining)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse RecipientIdentifier: %w", err)
        }</span>
        <span class="cov8" title="22">ktri.RID = rid
        remaining = rest

        // Parse keyEncryptionAlgorithm AlgorithmIdentifier
        var alg pkix.AlgorithmIdentifier
        rest, err = asn1.Unmarshal(remaining, &amp;alg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse keyEncryptionAlgorithm: %w", err)
        }</span>
        <span class="cov8" title="22">ktri.KeyEncryptionAlgorithm = alg
        remaining = rest

        // Parse encryptedKey OCTET STRING
        var encKey []byte
        _, err = asn1.Unmarshal(remaining, &amp;encKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse encryptedKey: %w", err)
        }</span>
        <span class="cov8" title="22">ktri.EncryptedKey = encKey

        return ktri, nil</span>
}

// KeyAgreeRecipientInfo for ECDH key agreement (RFC 5652 Section 6.2.2).
//
//        KeyAgreeRecipientInfo ::= SEQUENCE {
//          version CMSVersion,  -- always set to 3
//          originator [0] EXPLICIT OriginatorIdentifierOrKey,
//          ukm [1] EXPLICIT UserKeyingMaterial OPTIONAL,
//          keyEncryptionAlgorithm KeyEncryptionAlgorithmIdentifier,
//          recipientEncryptedKeys RecipientEncryptedKeys }
type KeyAgreeRecipientInfo struct {
        Version                int
        Originator             asn1.RawValue `asn1:"explicit,tag:0"`
        UKM                    []byte        `asn1:"optional,explicit,tag:1"`
        KeyEncryptionAlgorithm pkix.AlgorithmIdentifier
        RecipientEncryptedKeys []RecipientEncryptedKey `asn1:"sequence"`
}

// OriginatorIdentifierOrKey identifies the sender for key agreement.
//
//        OriginatorIdentifierOrKey ::= CHOICE {
//          issuerAndSerialNumber IssuerAndSerialNumber,
//          subjectKeyIdentifier [0] SubjectKeyIdentifier,
//          originatorKey [1] OriginatorPublicKey }
type OriginatorIdentifierOrKey struct {
        IssuerAndSerial *IssuerAndSerialNumber
        SKI             []byte               `asn1:"optional,tag:0"`
        OriginatorKey   *OriginatorPublicKey `asn1:"optional,tag:1"`
}

// OriginatorPublicKey contains ephemeral public key for key agreement.
//
//        OriginatorPublicKey ::= SEQUENCE {
//          algorithm AlgorithmIdentifier,
//          publicKey BIT STRING }
type OriginatorPublicKey struct {
        Algorithm pkix.AlgorithmIdentifier
        PublicKey asn1.BitString
}

// RecipientEncryptedKey contains the encrypted CEK for a recipient.
//
//        RecipientEncryptedKey ::= SEQUENCE {
//          rid KeyAgreeRecipientIdentifier,
//          encryptedKey EncryptedKey }
type RecipientEncryptedKey struct {
        RID          KeyAgreeRecipientIdentifier
        EncryptedKey []byte
}

// KeyAgreeRecipientIdentifier identifies recipient in key agreement.
//
//        KeyAgreeRecipientIdentifier ::= CHOICE {
//          issuerAndSerialNumber IssuerAndSerialNumber,
//          rKeyId [0] IMPLICIT RecipientKeyIdentifier }
type KeyAgreeRecipientIdentifier struct {
        IssuerAndSerial *IssuerAndSerialNumber
        RKeyID          *RecipientKeyIdentifier `asn1:"optional,tag:0"`
}

// Marshal encodes KeyAgreeRecipientIdentifier as ASN.1 DER.
func (karid KeyAgreeRecipientIdentifier) Marshal() ([]byte, error) <span class="cov6" title="10">{
        if karid.IssuerAndSerial != nil </span><span class="cov6" title="8">{
                return asn1.Marshal(*karid.IssuerAndSerial)
        }</span>
        <span class="cov2" title="2">if karid.RKeyID != nil </span><span class="cov1" title="1">{
                // Marshal as [0] IMPLICIT RecipientKeyIdentifier
                rkiBytes, err := asn1.Marshal(*karid.RKeyID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Wrap with [0] IMPLICIT tag
                <span class="cov1" title="1">return asn1.Marshal(asn1.RawValue{
                        Class:      asn1.ClassContextSpecific,
                        Tag:        0,
                        IsCompound: true,
                        Bytes:      rkiBytes[2:], // Skip SEQUENCE tag
                })</span>
        }
        <span class="cov1" title="1">return nil, asn1.StructuralError{Msg: "empty KeyAgreeRecipientIdentifier"}</span>
}

// RecipientKeyIdentifier for key agreement recipient.
type RecipientKeyIdentifier struct {
        SubjectKeyIdentifier []byte
        Date                 asn1.RawValue `asn1:"optional"`
        Other                asn1.RawValue `asn1:"optional"`
}

// ParseKeyAgreeRecipientIdentifier parses a KeyAgreeRecipientIdentifier from ASN.1 DER.
func ParseKeyAgreeRecipientIdentifier(data []byte) (KeyAgreeRecipientIdentifier, []byte, error) <span class="cov6" title="10">{
        var raw asn1.RawValue
        rest, err := asn1.Unmarshal(data, &amp;raw)
        if err != nil </span><span class="cov0" title="0">{
                return KeyAgreeRecipientIdentifier{}, nil, err
        }</span>

        <span class="cov6" title="10">var karid KeyAgreeRecipientIdentifier
        if raw.Tag == 0 &amp;&amp; raw.Class == asn1.ClassContextSpecific </span><span class="cov1" title="1">{
                // [0] RecipientKeyIdentifier
                var rki RecipientKeyIdentifier
                if _, err := asn1.Unmarshal(raw.Bytes, &amp;rki); err != nil </span><span class="cov0" title="0">{
                        return KeyAgreeRecipientIdentifier{}, nil, err
                }</span>
                <span class="cov1" title="1">karid.RKeyID = &amp;rki</span>
        } else<span class="cov6" title="9"> if raw.Tag == asn1.TagSequence &amp;&amp; raw.Class == asn1.ClassUniversal </span><span class="cov6" title="9">{
                // IssuerAndSerialNumber (SEQUENCE)
                var ias IssuerAndSerialNumber
                if _, err := asn1.Unmarshal(raw.FullBytes, &amp;ias); err != nil </span><span class="cov0" title="0">{
                        return KeyAgreeRecipientIdentifier{}, nil, err
                }</span>
                <span class="cov6" title="9">karid.IssuerAndSerial = &amp;ias</span>
        } else<span class="cov0" title="0"> {
                return KeyAgreeRecipientIdentifier{}, nil, asn1.StructuralError{
                        Msg: fmt.Sprintf("invalid KeyAgreeRecipientIdentifier: tag=%d, class=%d", raw.Tag, raw.Class),
                }
        }</span>

        <span class="cov6" title="10">return karid, rest, nil</span>
}

// ParseRecipientEncryptedKey parses a RecipientEncryptedKey from ASN.1 DER.
func ParseRecipientEncryptedKey(data []byte) (*RecipientEncryptedKey, []byte, error) <span class="cov6" title="8">{
        var raw asn1.RawValue
        rest, err := asn1.Unmarshal(data, &amp;raw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov6" title="8">if raw.Tag != asn1.TagSequence </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("expected SEQUENCE, got tag %d", raw.Tag)
        }</span>

        <span class="cov6" title="8">rek := &amp;RecipientEncryptedKey{}
        remaining := raw.Bytes

        // Parse KeyAgreeRecipientIdentifier (CHOICE)
        karid, rest2, err := ParseKeyAgreeRecipientIdentifier(remaining)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse KeyAgreeRecipientIdentifier: %w", err)
        }</span>
        <span class="cov6" title="8">rek.RID = karid
        remaining = rest2

        // Parse encryptedKey OCTET STRING
        var encKey []byte
        if _, err := asn1.Unmarshal(remaining, &amp;encKey); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse encryptedKey: %w", err)
        }</span>
        <span class="cov6" title="8">rek.EncryptedKey = encKey

        return rek, rest, nil</span>
}

// ParseKeyAgreeRecipientInfo parses a KeyAgreeRecipientInfo from ASN.1 DER.
// The data should be the SEQUENCE content (after tag/length).
func ParseKeyAgreeRecipientInfo(data []byte) (*KeyAgreeRecipientInfo, error) <span class="cov6" title="9">{
        remaining := data
        kari := &amp;KeyAgreeRecipientInfo{}

        // version INTEGER
        var version int
        rest, err := asn1.Unmarshal(remaining, &amp;version)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse version: %w", err)
        }</span>
        <span class="cov6" title="8">kari.Version = version
        remaining = rest

        // originator [0] EXPLICIT OriginatorIdentifierOrKey
        var originator asn1.RawValue
        rest, err = asn1.Unmarshal(remaining, &amp;originator)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse originator: %w", err)
        }</span>
        <span class="cov5" title="7">kari.Originator = originator
        remaining = rest

        // ukm [1] EXPLICIT OPTIONAL - check if next element is [1]
        var nextRaw asn1.RawValue
        peekRest, err := asn1.Unmarshal(remaining, &amp;nextRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to peek next element: %w", err)
        }</span>
        <span class="cov5" title="7">if nextRaw.Tag == 1 &amp;&amp; nextRaw.Class == asn1.ClassContextSpecific </span><span class="cov0" title="0">{
                // UKM is present
                var ukm []byte
                if _, err := asn1.Unmarshal(nextRaw.Bytes, &amp;ukm); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse UKM: %w", err)
                }</span>
                <span class="cov0" title="0">kari.UKM = ukm
                remaining = peekRest</span>
        }

        // keyEncryptionAlgorithm AlgorithmIdentifier
        <span class="cov5" title="7">var alg pkix.AlgorithmIdentifier
        rest, err = asn1.Unmarshal(remaining, &amp;alg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse keyEncryptionAlgorithm: %w", err)
        }</span>
        <span class="cov5" title="7">kari.KeyEncryptionAlgorithm = alg
        remaining = rest

        // recipientEncryptedKeys SEQUENCE OF RecipientEncryptedKey
        var reksRaw asn1.RawValue
        _, err = asn1.Unmarshal(remaining, &amp;reksRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse recipientEncryptedKeys: %w", err)
        }</span>
        <span class="cov5" title="7">if reksRaw.Tag != asn1.TagSequence </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected SEQUENCE for recipientEncryptedKeys, got tag %d", reksRaw.Tag)
        }</span>

        // Parse each RecipientEncryptedKey
        <span class="cov5" title="7">reksData := reksRaw.Bytes
        for len(reksData) &gt; 0 </span><span class="cov5" title="7">{
                rek, rest2, err := ParseRecipientEncryptedKey(reksData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse RecipientEncryptedKey: %w", err)
                }</span>
                <span class="cov5" title="7">kari.RecipientEncryptedKeys = append(kari.RecipientEncryptedKeys, *rek)
                reksData = rest2</span>
        }

        <span class="cov5" title="7">return kari, nil</span>
}

// MarshalRecipientEncryptedKey marshals a RecipientEncryptedKey.
func MarshalRecipientEncryptedKey(rek *RecipientEncryptedKey) ([]byte, error) <span class="cov5" title="7">{
        var b []byte

        // rid KeyAgreeRecipientIdentifier (CHOICE)
        ridBytes, err := rek.RID.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="7">b = append(b, ridBytes...)

        // encryptedKey OCTET STRING
        keyBytes, err := asn1.Marshal(rek.EncryptedKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="7">b = append(b, keyBytes...)

        // Wrap as SEQUENCE
        return asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      b,
        })</span>
}

// KEMRecipientInfo for ML-KEM (draft-ietf-lamps-cms-kemri).
//
//        KEMRecipientInfo ::= SEQUENCE {
//          version CMSVersion,  -- always 0
//          rid RecipientIdentifier,
//          kem KEMAlgorithmIdentifier,
//          kemct OCTET STRING,
//          kdf KeyDerivationAlgorithmIdentifier,
//          kekLength INTEGER (1..65535),
//          ukm [0] EXPLICIT UserKeyingMaterial OPTIONAL,
//          wrap KeyEncryptionAlgorithmIdentifier,
//          encryptedKey EncryptedKey }
type KEMRecipientInfo struct {
        Version      int
        RID          RecipientIdentifier
        KEM          pkix.AlgorithmIdentifier
        KEMCT        []byte // KEM ciphertext
        KDF          pkix.AlgorithmIdentifier
        KEKLength    int
        UKM          []byte `asn1:"optional,explicit,tag:0"`
        Wrap         pkix.AlgorithmIdentifier
        EncryptedKey []byte
}

// GCMParameters for AES-GCM (RFC 5084).
//
//        GCMParameters ::= SEQUENCE {
//          aes-nonce        OCTET STRING,
//          aes-ICVlen       AES-GCM-ICVlen DEFAULT 12 }
type GCMParameters struct {
        Nonce  []byte
        ICVLen int `asn1:"optional,default:12"`
}

// RSAOAEPParams for RSA-OAEP (RFC 4055).
//
//        RSAES-OAEP-params ::= SEQUENCE {
//          hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1,
//          maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,
//          pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty }
type RSAOAEPParams struct {
        HashAlgorithm    pkix.AlgorithmIdentifier `asn1:"optional,explicit,tag:0"`
        MaskGenAlgorithm pkix.AlgorithmIdentifier `asn1:"optional,explicit,tag:1"`
        PSourceAlgorithm pkix.AlgorithmIdentifier `asn1:"optional,explicit,tag:2"`
}

// MarshalKeyTransRecipientInfo marshals KeyTransRecipientInfo.
// This manually constructs the ASN.1 SEQUENCE because RecipientIdentifier
// is a CHOICE type that Go's encoding/asn1 cannot automatically marshal.
func MarshalKeyTransRecipientInfo(ktri *KeyTransRecipientInfo) ([]byte, error) <span class="cov8" title="23">{
        var b []byte

        // version INTEGER
        versionBytes, err := asn1.Marshal(ktri.Version)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="23">b = append(b, versionBytes...)

        // rid RecipientIdentifier (CHOICE - requires manual marshaling)
        ridBytes, err := ktri.RID.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="23">b = append(b, ridBytes...)

        // keyEncryptionAlgorithm AlgorithmIdentifier
        algBytes, err := asn1.Marshal(ktri.KeyEncryptionAlgorithm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="23">b = append(b, algBytes...)

        // encryptedKey OCTET STRING
        keyBytes, err := asn1.Marshal(ktri.EncryptedKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="23">b = append(b, keyBytes...)

        // Wrap as SEQUENCE
        return asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      b,
        })</span>
}

// MarshalKeyAgreeRecipientInfo marshals KeyAgreeRecipientInfo with [1] IMPLICIT tag.
// This manually constructs the ASN.1 because RecipientEncryptedKey contains
// KeyAgreeRecipientIdentifier which is a CHOICE type.
func MarshalKeyAgreeRecipientInfo(kari *KeyAgreeRecipientInfo) ([]byte, error) <span class="cov5" title="6">{
        var b []byte

        // version INTEGER
        versionBytes, err := asn1.Marshal(kari.Version)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="6">b = append(b, versionBytes...)

        // originator [0] EXPLICIT OriginatorIdentifierOrKey
        // The Originator is stored as RawValue, we need to wrap it properly
        var originatorBytes []byte
        if len(kari.Originator.FullBytes) &gt; 0 </span><span class="cov4" title="5">{
                originatorBytes = kari.Originator.FullBytes
        }</span> else<span class="cov1" title="1"> {
                // Construct from Bytes with proper tag
                originatorBytes, err = asn1.Marshal(asn1.RawValue{
                        Class:      kari.Originator.Class,
                        Tag:        kari.Originator.Tag,
                        IsCompound: kari.Originator.IsCompound,
                        Bytes:      kari.Originator.Bytes,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal originator: %w", err)
                }</span>
        }
        // Wrap with [0] EXPLICIT tag
        <span class="cov5" title="6">originatorWrapped, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassContextSpecific,
                Tag:        0,
                IsCompound: true,
                Bytes:      originatorBytes,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to wrap originator: %w", err)
        }</span>
        <span class="cov5" title="6">b = append(b, originatorWrapped...)

        // ukm [1] EXPLICIT OPTIONAL
        if len(kari.UKM) &gt; 0 </span><span class="cov0" title="0">{
                ukmInner, err := asn1.Marshal(kari.UKM)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">ukmBytes, err := asn1.Marshal(asn1.RawValue{
                        Class:      asn1.ClassContextSpecific,
                        Tag:        1,
                        IsCompound: true,
                        Bytes:      ukmInner,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">b = append(b, ukmBytes...)</span>
        }

        // keyEncryptionAlgorithm AlgorithmIdentifier
        <span class="cov5" title="6">algBytes, err := asn1.Marshal(kari.KeyEncryptionAlgorithm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="6">b = append(b, algBytes...)

        // recipientEncryptedKeys SEQUENCE OF RecipientEncryptedKey
        var reksBytes []byte
        for i := range kari.RecipientEncryptedKeys </span><span class="cov5" title="6">{
                rekBytes, err := MarshalRecipientEncryptedKey(&amp;kari.RecipientEncryptedKeys[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="6">reksBytes = append(reksBytes, rekBytes...)</span>
        }
        // Wrap as SEQUENCE
        <span class="cov5" title="6">reksSeq, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      reksBytes,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="6">b = append(b, reksSeq...)

        // Wrap content as SEQUENCE, then apply [1] IMPLICIT tag
        seqBytes, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      b,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to [1] IMPLICIT by changing the tag
        // seqBytes[0] is 0x30 (SEQUENCE), change to 0xa1 ([1] context-specific constructed)
        <span class="cov5" title="6">result := make([]byte, len(seqBytes))
        copy(result, seqBytes)
        result[0] = 0xa1 // [1] IMPLICIT context-specific constructed

        return result, nil</span>
}

// MarshalKEMRecipientInfo marshals KEMRecipientInfo wrapped in OtherRecipientInfo [4].
// Per RFC 9629, KEMRecipientInfo must be wrapped in OtherRecipientInfo with id-ori-kem OID.
func MarshalKEMRecipientInfo(kemri *KEMRecipientInfo) ([]byte, error) <span class="cov6" title="10">{
        // Build the KEMRecipientInfo SEQUENCE content manually for proper encoding
        var kemriContent []byte

        // version INTEGER
        versionBytes, err := asn1.Marshal(kemri.Version)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="10">kemriContent = append(kemriContent, versionBytes...)

        // rid RecipientIdentifier (IssuerAndSerialNumber)
        if kemri.RID.IssuerAndSerial != nil </span><span class="cov6" title="10">{
                ridBytes, err := asn1.Marshal(*kemri.RID.IssuerAndSerial)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="10">kemriContent = append(kemriContent, ridBytes...)</span>
        }

        // kem AlgorithmIdentifier
        <span class="cov6" title="10">kemBytes, err := asn1.Marshal(kemri.KEM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="10">kemriContent = append(kemriContent, kemBytes...)

        // kemct OCTET STRING
        kemctBytes, err := asn1.Marshal(kemri.KEMCT)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="10">kemriContent = append(kemriContent, kemctBytes...)

        // kdf AlgorithmIdentifier
        kdfBytes, err := asn1.Marshal(kemri.KDF)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="10">kemriContent = append(kemriContent, kdfBytes...)

        // kekLength INTEGER
        kekLenBytes, err := asn1.Marshal(kemri.KEKLength)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="10">kemriContent = append(kemriContent, kekLenBytes...)

        // ukm [0] EXPLICIT OPTIONAL - skip if empty
        if len(kemri.UKM) &gt; 0 </span><span class="cov0" title="0">{
                ukmInner, err := asn1.Marshal(kemri.UKM)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">ukmBytes, err := asn1.Marshal(asn1.RawValue{
                        Class:      asn1.ClassContextSpecific,
                        Tag:        0,
                        IsCompound: true,
                        Bytes:      ukmInner,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">kemriContent = append(kemriContent, ukmBytes...)</span>
        }

        // wrap AlgorithmIdentifier
        <span class="cov6" title="10">wrapBytes, err := asn1.Marshal(kemri.Wrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="10">kemriContent = append(kemriContent, wrapBytes...)

        // encryptedKey OCTET STRING
        encKeyBytes, err := asn1.Marshal(kemri.EncryptedKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="10">kemriContent = append(kemriContent, encKeyBytes...)

        // Build KEMRecipientInfo as SEQUENCE
        kemriSeqBytes, err := asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      kemriContent,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build OtherRecipientInfo SEQUENCE content:
        // OtherRecipientInfo ::= SEQUENCE { oriType OID, oriValue ANY }
        <span class="cov6" title="10">var oriContent []byte

        // oriType: id-ori-kem OID
        oriTypeBytes, err := asn1.Marshal(OIDOriKEM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="10">oriContent = append(oriContent, oriTypeBytes...)

        // oriValue: KEMRecipientInfo (already a SEQUENCE)
        oriContent = append(oriContent, kemriSeqBytes...)

        // Wrap as [4] IMPLICIT SEQUENCE (OtherRecipientInfo)
        return asn1.Marshal(asn1.RawValue{
                Class:      asn1.ClassContextSpecific,
                Tag:        4,
                IsCompound: true,
                Bytes:      oriContent,
        })</span>
}

// ParseKEMRecipientInfo parses a KEMRecipientInfo from DER bytes.
// This handles the RecipientIdentifier CHOICE properly.
func ParseKEMRecipientInfo(data []byte) (*KEMRecipientInfo, error) <span class="cov7" title="12">{
        remaining := data
        kemri := &amp;KEMRecipientInfo{}

        // version INTEGER
        var version int
        rest, err := asn1.Unmarshal(remaining, &amp;version)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse version: %w", err)
        }</span>
        <span class="cov6" title="11">kemri.Version = version
        remaining = rest

        // rid RecipientIdentifier (CHOICE)
        rid, rest, err := ParseRecipientIdentifier(remaining)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse RecipientIdentifier: %w", err)
        }</span>
        <span class="cov6" title="10">kemri.RID = rid
        remaining = rest

        // kem AlgorithmIdentifier
        var kem pkix.AlgorithmIdentifier
        rest, err = asn1.Unmarshal(remaining, &amp;kem)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse KEM algorithm: %w", err)
        }</span>
        <span class="cov6" title="10">kemri.KEM = kem
        remaining = rest

        // kemct OCTET STRING
        var kemct []byte
        rest, err = asn1.Unmarshal(remaining, &amp;kemct)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse KEMCT: %w", err)
        }</span>
        <span class="cov6" title="10">kemri.KEMCT = kemct
        remaining = rest

        // kdf AlgorithmIdentifier
        var kdf pkix.AlgorithmIdentifier
        rest, err = asn1.Unmarshal(remaining, &amp;kdf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse KDF algorithm: %w", err)
        }</span>
        <span class="cov6" title="10">kemri.KDF = kdf
        remaining = rest

        // kekLength INTEGER
        var kekLength int
        rest, err = asn1.Unmarshal(remaining, &amp;kekLength)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse KEK length: %w", err)
        }</span>
        <span class="cov6" title="10">kemri.KEKLength = kekLength
        remaining = rest

        // ukm [0] EXPLICIT OPTIONAL
        var nextRaw asn1.RawValue
        rest, err = asn1.Unmarshal(remaining, &amp;nextRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to peek next element: %w", err)
        }</span>
        <span class="cov6" title="10">if nextRaw.Tag == 0 &amp;&amp; nextRaw.Class == asn1.ClassContextSpecific </span><span class="cov0" title="0">{
                // UKM is present
                var ukm []byte
                if _, err := asn1.Unmarshal(nextRaw.Bytes, &amp;ukm); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse UKM: %w", err)
                }</span>
                <span class="cov0" title="0">kemri.UKM = ukm
                remaining = rest
                // Re-peek for wrap
                rest, err = asn1.Unmarshal(remaining, &amp;nextRaw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse after UKM: %w", err)
                }</span>
        }

        // wrap AlgorithmIdentifier - we already have nextRaw from above
        <span class="cov6" title="10">var wrap pkix.AlgorithmIdentifier
        if nextRaw.Tag == asn1.TagSequence &amp;&amp; nextRaw.Class == asn1.ClassUniversal </span><span class="cov6" title="10">{
                if _, err := asn1.Unmarshal(nextRaw.FullBytes, &amp;wrap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse wrap algorithm: %w", err)
                }</span>
                <span class="cov6" title="10">remaining = rest</span>
        } else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("expected wrap AlgorithmIdentifier, got tag=%d", nextRaw.Tag)
        }</span>
        <span class="cov6" title="10">kemri.Wrap = wrap

        // encryptedKey OCTET STRING
        var encKey []byte
        _, err = asn1.Unmarshal(remaining, &amp;encKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse encrypted key: %w", err)
        }</span>
        <span class="cov6" title="10">kemri.EncryptedKey = encKey

        return kemri, nil</span>
}

// ParseRecipientInfo parses a RecipientInfo from RawValue.
func ParseRecipientInfo(raw asn1.RawValue) (interface{}, error) <span class="cov3" title="3">{
        switch raw.Tag </span>{
        case asn1.TagSequence:<span class="cov1" title="1">
                // KeyTransRecipientInfo (default, no tag)
                // Use custom parser to handle RecipientIdentifier CHOICE
                return ParseKeyTransRecipientInfo(raw.FullBytes)</span>

        case 1:<span class="cov1" title="1">
                // [1] KeyAgreeRecipientInfo
                // Use custom parser - raw.Bytes doesn't have SEQUENCE wrapper
                return ParseKeyAgreeRecipientInfo(raw.Bytes)</span>

        case 2:<span class="cov0" title="0">
                // [2] KEMRecipientInfo
                // Use custom parser - raw.Bytes doesn't have SEQUENCE wrapper
                return ParseKEMRecipientInfo(raw.Bytes)</span>

        default:<span class="cov1" title="1">
                return nil, asn1.StructuralError{Msg: "unsupported RecipientInfo type"}</span>
        }
}

// RecipientIdentifierFromCert creates a RecipientIdentifier from a certificate.
func RecipientIdentifierFromCert(serialNumber *big.Int, issuerRaw []byte) RecipientIdentifier <span class="cov2" title="2">{
        return RecipientIdentifier{
                IssuerAndSerial: &amp;IssuerAndSerialNumber{
                        Issuer:       asn1.RawValue{FullBytes: issuerRaw},
                        SerialNumber: serialNumber,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package cms implements Cryptographic Message Syntax (RFC 5652).
package cms

import (
        "errors"
        "fmt"
)

// CMSError represents a CMS operation error with structured context.
// It supports errors.Is() and errors.As() for improved error handling.
type CMSError struct {
        Op  string // Operation: "sign", "verify", "encrypt", "decrypt", "parse", "envelop"
        Err error  // Underlying error
}

// Error implements the error interface.
func (e *CMSError) Error() string <span class="cov8" title="4">{
        return fmt.Sprintf("cms %s: %v", e.Op, e.Err)
}</span>

// Unwrap returns the underlying error for errors.Is/As support.
func (e *CMSError) Unwrap() error <span class="cov7" title="3">{ return e.Err }</span>

// NewCMSError creates a new CMSError with the given operation and error.
func NewCMSError(op string, err error) *CMSError <span class="cov10" title="5">{
        return &amp;CMSError{Op: op, Err: err}
}</span>

// Sentinel errors for CMS operations.
// Use errors.Is() to check for these errors through the error chain.
var (
        // ErrInvalidSignature indicates signature verification failed.
        ErrInvalidSignature = errors.New("invalid signature")

        // ErrNoCertificate indicates no certificate was found in the CMS structure.
        ErrNoCertificate = errors.New("no certificate found")

        // ErrDecryptFailed indicates decryption of the CMS content failed.
        ErrDecryptFailed = errors.New("decryption failed")

        // ErrEncryptFailed indicates encryption of the CMS content failed.
        ErrEncryptFailed = errors.New("encryption failed")

        // ErrInvalidContent indicates the CMS content is malformed.
        ErrInvalidContent = errors.New("invalid CMS content")

        // ErrNoSigner indicates no signer information was found.
        ErrNoSigner = errors.New("no signer information")

        // ErrUnsupportedAlgorithm indicates an unsupported cryptographic algorithm.
        ErrUnsupportedAlgorithm = errors.New("unsupported algorithm")

        // ErrMissingAttribute indicates a required signed attribute is missing.
        ErrMissingAttribute = errors.New("missing signed attribute")

        // ErrInvalidRecipient indicates the recipient information is invalid.
        ErrInvalidRecipient = errors.New("invalid recipient information")

        // ErrNoRecipient indicates no matching recipient was found for decryption.
        ErrNoRecipient = errors.New("no matching recipient")
)
</pre>
		
		<pre class="file" id="file4" style="display: none">package cms

import (
        "encoding/asn1"
        "fmt"
)

// ParseContentInfo parses a CMS ContentInfo structure.
// This is the top-level wrapper for all CMS message types.
func ParseContentInfo(data []byte) (*ContentInfo, error) <span class="cov9" title="6">{
        var ci ContentInfo
        _, err := asn1.Unmarshal(data, &amp;ci)
        if err != nil </span><span class="cov6" title="3">{
                return nil, fmt.Errorf("failed to parse ContentInfo: %w", err)
        }</span>
        <span class="cov6" title="3">return &amp;ci, nil</span>
}

// ParseSignedData parses a CMS SignedData structure from raw DER bytes.
// The input should be a complete ContentInfo containing SignedData.
func ParseSignedData(data []byte) (*SignedData, error) <span class="cov10" title="7">{
        var ci ContentInfo
        _, err := asn1.Unmarshal(data, &amp;ci)
        if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("failed to parse ContentInfo: %w", err)
        }</span>

        <span class="cov8" title="5">if !ci.ContentType.Equal(OIDSignedData) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a SignedData structure, got OID %v", ci.ContentType)
        }</span>

        <span class="cov8" title="5">var sd SignedData
        _, err = asn1.Unmarshal(ci.Content.Bytes, &amp;sd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse SignedData: %w", err)
        }</span>

        <span class="cov8" title="5">return &amp;sd, nil</span>
}

// ParseEnvelopedData parses a CMS EnvelopedData structure from raw DER bytes.
// The input should be a complete ContentInfo containing EnvelopedData.
func ParseEnvelopedData(data []byte) (*EnvelopedData, error) <span class="cov6" title="3">{
        var ci ContentInfo
        _, err := asn1.Unmarshal(data, &amp;ci)
        if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("failed to parse ContentInfo: %w", err)
        }</span>

        <span class="cov1" title="1">if !ci.ContentType.Equal(OIDEnvelopedData) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not an EnvelopedData structure, got OID %v", ci.ContentType)
        }</span>

        <span class="cov1" title="1">var env EnvelopedData
        _, err = asn1.Unmarshal(ci.Content.Bytes, &amp;env)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse EnvelopedData: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;env, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cms

import (
        "bytes"
        "crypto/sha256"
        "crypto/x509/pkix"
        "encoding/asn1"
        "math/big"
        "sort"
        "time"
)

// ContentInfo represents the top-level CMS structure (RFC 5652 Section 3).
type ContentInfo struct {
        ContentType asn1.ObjectIdentifier
        Content     asn1.RawValue `asn1:"explicit,tag:0"`
}

// SignedData represents CMS SignedData (RFC 5652 Section 5).
type SignedData struct {
        Version          int
        DigestAlgorithms []pkix.AlgorithmIdentifier `asn1:"set"`
        EncapContentInfo EncapsulatedContentInfo
        Certificates     rawCertificates `asn1:"optional,tag:0"`
        CRLs             []asn1.RawValue `asn1:"optional,set,tag:1"`
        SignerInfos      []SignerInfo    `asn1:"set"`
}

// rawCertificates is used to handle the IMPLICIT tag [0] for certificates.
type rawCertificates struct {
        Raw asn1.RawContent
}

// EncapsulatedContentInfo represents the content being signed (RFC 5652 Section 5.2).
// Note: EContent is [0] EXPLICIT OCTET STRING - we handle the tagging in the RawValue
// rather than using struct tags, because Go's asn1 doesn't properly apply tags to RawValue.
type EncapsulatedContentInfo struct {
        EContentType asn1.ObjectIdentifier
        EContent     asn1.RawValue `asn1:"optional"`
}

// SignerInfo contains the signature and related info (RFC 5652 Section 5.3).
// Note: SID is IssuerAndSerialNumber directly (not wrapped in SignerIdentifier)
// because SignerIdentifier is a CHOICE in ASN.1, not a SEQUENCE.
type SignerInfo struct {
        Version            int
        SID                IssuerAndSerialNumber
        DigestAlgorithm    pkix.AlgorithmIdentifier
        SignedAttrs        []Attribute `asn1:"optional,tag:0"`
        SignatureAlgorithm pkix.AlgorithmIdentifier
        Signature          []byte
        UnsignedAttrs      []Attribute `asn1:"optional,tag:1"`
}

// IssuerAndSerialNumber identifies a certificate by issuer and serial.
type IssuerAndSerialNumber struct {
        Issuer       asn1.RawValue
        SerialNumber *big.Int
}

// Attribute represents a CMS attribute (RFC 5652 Section 5.3).
type Attribute struct {
        Type   asn1.ObjectIdentifier
        Values []asn1.RawValue `asn1:"set"`
}

// NewAttribute creates a new attribute with a single value.
func NewAttribute(oid asn1.ObjectIdentifier, value interface{}) (Attribute, error) <span class="cov9" title="432">{
        encoded, err := asn1.Marshal(value)
        if err != nil </span><span class="cov1" title="1">{
                return Attribute{}, err
        }</span>
        <span class="cov9" title="431">return Attribute{
                Type:   oid,
                Values: []asn1.RawValue{{FullBytes: encoded}},
        }, nil</span>
}

// NewContentTypeAttr creates a content-type attribute.
func NewContentTypeAttr(contentType asn1.ObjectIdentifier) (Attribute, error) <span class="cov7" title="141">{
        return NewAttribute(OIDContentType, contentType)
}</span>

// NewMessageDigestAttr creates a message-digest attribute.
func NewMessageDigestAttr(digest []byte) (Attribute, error) <span class="cov7" title="141">{
        return NewAttribute(OIDMessageDigest, digest)
}</span>

// NewSigningTimeAttr creates a signing-time attribute.
func NewSigningTimeAttr(t time.Time) (Attribute, error) <span class="cov7" title="141">{
        return NewAttribute(OIDSigningTime, t.UTC())
}</span>

// ESSCertIDv2 represents the ESSCertIDv2 structure (RFC 5035).
// Used for the signing-certificate-v2 attribute required by RFC 5816 for TSA.
type ESSCertIDv2 struct {
        HashAlgorithm pkix.AlgorithmIdentifier `asn1:"optional"`
        CertHash      []byte
        IssuerSerial  ESSIssuerSerial `asn1:"optional"`
}

// ESSIssuerSerial identifies a certificate by issuer and serial for ESSCertIDv2.
type ESSIssuerSerial struct {
        Issuer       asn1.RawValue // GeneralNames
        SerialNumber *big.Int
}

// SigningCertificateV2 represents the SigningCertificateV2 attribute value (RFC 5035).
type SigningCertificateV2 struct {
        Certs []ESSCertIDv2
        // Policies omitted - optional and rarely used
}

// NewSigningCertificateV2Attr creates a signing-certificate-v2 attribute (RFC 5035).
// This attribute is required by RFC 5816 for timestamp tokens.
func NewSigningCertificateV2Attr(certDER []byte, issuerRaw []byte, serialNumber *big.Int) (Attribute, error) <span class="cov3" title="7">{
        // Compute SHA-256 hash of the certificate
        h := sha256.Sum256(certDER)

        // Build IssuerSerial with GeneralNames containing directoryName
        // GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
        // GeneralName ::= CHOICE { directoryName [4] Name }
        directoryName := asn1.RawValue{
                Class:      asn1.ClassContextSpecific,
                Tag:        4,
                IsCompound: true,
                Bytes:      issuerRaw,
        }
        generalNamesBytes, err := asn1.Marshal(directoryName)
        if err != nil </span><span class="cov0" title="0">{
                return Attribute{}, err
        }</span>
        // Wrap in SEQUENCE for GeneralNames
        <span class="cov3" title="7">generalNames := asn1.RawValue{
                Class:      asn1.ClassUniversal,
                Tag:        asn1.TagSequence,
                IsCompound: true,
                Bytes:      generalNamesBytes,
        }
        generalNamesFullBytes, err := asn1.Marshal(generalNames)
        if err != nil </span><span class="cov0" title="0">{
                return Attribute{}, err
        }</span>

        <span class="cov3" title="7">issuerSerial := ESSIssuerSerial{
                Issuer:       asn1.RawValue{FullBytes: generalNamesFullBytes},
                SerialNumber: serialNumber,
        }

        essCertID := ESSCertIDv2{
                // HashAlgorithm omitted = default SHA-256 per RFC 5035
                CertHash:     h[:],
                IssuerSerial: issuerSerial,
        }

        signingCert := SigningCertificateV2{
                Certs: []ESSCertIDv2{essCertID},
        }

        return NewAttribute(OIDSigningCertificateV2, signingCert)</span>
}

// MarshalSignedAttrs marshals signed attributes for signing.
// Per RFC 5652, signed attributes must be DER-encoded as a SET OF.
// DER requires SET OF elements to be sorted by their DER encoding.
func MarshalSignedAttrs(attrs []Attribute) ([]byte, error) <span class="cov8" title="258">{
        // First, encode each attribute individually and sort
        encodedAttrs := make([][]byte, len(attrs))
        for i, attr := range attrs </span><span class="cov10" title="787">{
                encoded, err := asn1.Marshal(attr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="787">encodedAttrs[i] = encoded</span>
        }

        // Sort by DER encoding (lexicographic byte comparison)
        <span class="cov8" title="258">sort.Slice(encodedAttrs, func(i, j int) bool </span><span class="cov9" title="535">{
                return bytes.Compare(encodedAttrs[i], encodedAttrs[j]) &lt; 0
        }</span>)

        // Calculate total length
        <span class="cov8" title="258">totalLen := 0
        for _, enc := range encodedAttrs </span><span class="cov10" title="787">{
                totalLen += len(enc)
        }</span>

        // Build SET OF with sorted elements
        <span class="cov8" title="258">result := make([]byte, 0, totalLen+4)
        result = append(result, 0x31) // SET tag

        // Encode length
        if totalLen &lt; 128 </span><span class="cov8" title="189">{
                result = append(result, byte(totalLen))
        }</span> else<span class="cov6" title="69"> if totalLen &lt; 256 </span><span class="cov6" title="68">{
                result = append(result, 0x81, byte(totalLen))
        }</span> else<span class="cov1" title="1"> {
                result = append(result, 0x82, byte(totalLen&gt;&gt;8), byte(totalLen))
        }</span>

        // Append sorted elements
        <span class="cov8" title="258">for _, enc := range encodedAttrs </span><span class="cov10" title="787">{
                result = append(result, enc...)
        }</span>

        <span class="cov8" title="258">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cms

import (
        "bytes"
        "context"
        "crypto"
        "crypto/ecdsa"
        "crypto/ed25519"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/sha512"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/asn1"
        "fmt"
        "hash"
        "sort"
        "time"

        "github.com/cloudflare/circl/sign/ed448"
        "github.com/remiblancher/post-quantum-pki/internal/ca"
        pkicrypto "github.com/remiblancher/post-quantum-pki/internal/crypto"
        "github.com/remiblancher/post-quantum-pki/internal/x509util"
        "golang.org/x/crypto/sha3"
)

// SignerConfig contains options for signing.
type SignerConfig struct {
        Certificate          *x509.Certificate
        Signer               crypto.Signer
        DigestAlg            crypto.Hash
        IncludeCerts         bool
        SigningTime          time.Time
        ContentType          asn1.ObjectIdentifier
        Detached             bool // If true, content is not included in SignedData
        IncludeSigningCertV2 bool // If true, include ESSCertIDv2 attribute (RFC 5816 TSA)
}

// selectDigestForSigner returns the appropriate digest algorithm based on the signer's
// algorithm and certificate type, following RFC 9882 (ML-DSA) and RFC 9814 (SLH-DSA).
// If the digest is explicitly specified in SignerConfig, it takes precedence.
func selectDigestForSigner(signer crypto.Signer, cert *x509.Certificate) crypto.Hash <span class="cov7" title="89">{
        certType := x509util.GetCertificateType(cert)

        if certType == x509util.CertTypePQC </span><span class="cov6" title="63">{
                alg := pkicrypto.AlgorithmFromPublicKey(signer.Public())
                switch alg </span>{
                // RFC 9882: ML-DSA digest selection based on security level
                case pkicrypto.AlgMLDSA87:<span class="cov2" title="4">
                        return crypto.SHA512</span> // NIST Level 5
                case pkicrypto.AlgMLDSA65:<span class="cov3" title="5">
                        return crypto.SHA384</span> // NIST Level 3
                case pkicrypto.AlgMLDSA44:<span class="cov3" title="5">
                        return crypto.SHA256</span> // NIST Level 1

                // RFC 9814: SLH-DSA digest selection based on security level
                // 128-bit security  SHA-256, 192/256-bit security  SHA-512
                case pkicrypto.AlgSLHDSASHA2128s, pkicrypto.AlgSLHDSASHA2128f,
                        pkicrypto.AlgSLHDSASHAKE128s, pkicrypto.AlgSLHDSASHAKE128f:<span class="cov5" title="27">
                        return crypto.SHA256</span> // NIST Level 1
                case pkicrypto.AlgSLHDSASHA2192s, pkicrypto.AlgSLHDSASHA2192f,
                        pkicrypto.AlgSLHDSASHAKE192s, pkicrypto.AlgSLHDSASHAKE192f:<span class="cov4" title="11">
                        return crypto.SHA512</span> // NIST Level 3
                case pkicrypto.AlgSLHDSASHA2256s, pkicrypto.AlgSLHDSASHA2256f,
                        pkicrypto.AlgSLHDSASHAKE256s, pkicrypto.AlgSLHDSASHAKE256f:<span class="cov4" title="11">
                        return crypto.SHA512</span> // NIST Level 5

                default:<span class="cov0" title="0">
                        // Unknown PQC - default to SHA-256
                        return crypto.SHA256</span>
                }
        }

        // Classical algorithms: default to SHA-256
        <span class="cov5" title="26">return crypto.SHA256</span>
}

// Sign creates a CMS SignedData structure.
func Sign(ctx context.Context, content []byte, config *SignerConfig) ([]byte, error) <span class="cov8" title="139">{
        _ = ctx // TODO: use for cancellation
        if config.Certificate == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("certificate is required")
        }</span>
        <span class="cov8" title="138">if config.Signer == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("signer is required")
        }</span>
        <span class="cov8" title="137">if config.DigestAlg == 0 </span><span class="cov7" title="69">{
                // Auto-select digest based on signer algorithm (RFC 9882)
                config.DigestAlg = selectDigestForSigner(config.Signer, config.Certificate)
        }</span>
        <span class="cov8" title="137">if config.SigningTime.IsZero() </span><span class="cov7" title="136">{
                config.SigningTime = time.Now().UTC()
        }</span>
        <span class="cov8" title="137">if len(config.ContentType) == 0 </span><span class="cov7" title="136">{
                config.ContentType = OIDData
        }</span>

        // Compute content digest
        <span class="cov8" title="137">digest, err := computeDigest(content, config.DigestAlg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to compute digest: %w", err)
        }</span>

        // Build signed attributes
        <span class="cov8" title="137">signedAttrs, err := buildSignedAttrs(&amp;buildSignedAttrsConfig{
                ContentType:          config.ContentType,
                Digest:               digest,
                SigningTime:          config.SigningTime,
                IncludeSigningCertV2: config.IncludeSigningCertV2,
                Certificate:          config.Certificate,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build signed attributes: %w", err)
        }</span>

        // Sort attributes in DER order (required for SET OF encoding)
        // This sorted list is used both for signing AND for storage in SignerInfo
        <span class="cov8" title="137">signedAttrs, err = sortAttributes(signedAttrs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sort signed attributes: %w", err)
        }</span>

        // Marshal signed attributes for signing
        <span class="cov8" title="137">signedAttrsDER, err := MarshalSignedAttrs(signedAttrs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal signed attributes: %w", err)
        }</span>

        // Sign the attributes
        // The CERTIFICATE dictates the signature format:
        // - Catalyst: classical signature only
        // - Composite: composite signature (ML-DSA + ECDSA)
        // - PQC: PQC signature only
        // - Classical: classical signature
        <span class="cov8" title="137">signature, err := signDataWithCert(signedAttrsDER, config.Signer, config.DigestAlg, config.Certificate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign: %w", err)
        }</span>

        // Get algorithm identifiers
        <span class="cov8" title="137">digestAlgID := getDigestAlgorithmIdentifier(config.DigestAlg)
        sigAlgID, err := getSignatureAlgorithmIdentifierWithCert(config.Signer, config.DigestAlg, config.Certificate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get signature algorithm: %w", err)
        }</span>

        // Build SignerInfo
        <span class="cov8" title="137">signerInfo := SignerInfo{
                Version: 1,
                SID: IssuerAndSerialNumber{
                        Issuer:       asn1.RawValue{FullBytes: config.Certificate.RawIssuer},
                        SerialNumber: config.Certificate.SerialNumber,
                },
                DigestAlgorithm:    digestAlgID,
                SignedAttrs:        signedAttrs,
                SignatureAlgorithm: sigAlgID,
                Signature:          signature,
        }

        // Build EncapsulatedContentInfo
        encapContent := EncapsulatedContentInfo{
                EContentType: config.ContentType,
        }
        // For attached signatures, include the content
        if !config.Detached </span><span class="cov7" title="125">{
                // EContent is [0] EXPLICIT OCTET STRING
                // We need to encode the OCTET STRING first, then wrap it in [0] EXPLICIT
                octetString, err := asn1.Marshal(content)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to encode content: %w", err)
                }</span>
                // Use RawValue with Class and Tag to tell asn1 to output as [0]
                // The Bytes field contains the OCTET STRING (already encoded)
                <span class="cov7" title="125">encapContent.EContent = asn1.RawValue{
                        Class:      asn1.ClassContextSpecific,
                        Tag:        0,
                        IsCompound: true,
                        Bytes:      octetString,
                }</span>
        }

        // Build SignedData
        <span class="cov8" title="137">signedData := SignedData{
                Version:          1,
                DigestAlgorithms: []pkix.AlgorithmIdentifier{digestAlgID},
                EncapContentInfo: encapContent,
                SignerInfos:      []SignerInfo{signerInfo},
        }

        // Marshal SignedData first without certificates
        signedDataDER, err := asn1.Marshal(signedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal SignedData: %w", err)
        }</span>

        // Include certificates if requested - inject them manually
        <span class="cov8" title="137">if config.IncludeCerts </span><span class="cov7" title="136">{
                signedDataDER, err = injectCertificates(signedDataDER, config.Certificate.Raw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to inject certificates: %w", err)
                }</span>
        }

        // Wrap in ContentInfo
        <span class="cov8" title="137">contentInfo := ContentInfo{
                ContentType: OIDSignedData,
                Content:     asn1.RawValue{Class: asn1.ClassContextSpecific, Tag: 0, IsCompound: true, Bytes: signedDataDER},
        }

        return asn1.Marshal(contentInfo)</span>
}

// buildSignedAttrsConfig contains options for building signed attributes.
type buildSignedAttrsConfig struct {
        ContentType          asn1.ObjectIdentifier
        Digest               []byte
        SigningTime          time.Time
        IncludeSigningCertV2 bool
        Certificate          *x509.Certificate // Required if IncludeSigningCertV2 is true
}

func buildSignedAttrs(config *buildSignedAttrsConfig) ([]Attribute, error) <span class="cov8" title="138">{
        ctAttr, err := NewContentTypeAttr(config.ContentType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="138">mdAttr, err := NewMessageDigestAttr(config.Digest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="138">stAttr, err := NewSigningTimeAttr(config.SigningTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="138">attrs := []Attribute{ctAttr, mdAttr, stAttr}

        // Add ESSCertIDv2 (signing-certificate-v2) if requested (RFC 5816 for TSA)
        if config.IncludeSigningCertV2 &amp;&amp; config.Certificate != nil </span><span class="cov1" title="1">{
                scAttr, err := NewSigningCertificateV2Attr(
                        config.Certificate.Raw,
                        config.Certificate.RawIssuer,
                        config.Certificate.SerialNumber,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create signing-certificate-v2 attr: %w", err)
                }</span>
                <span class="cov1" title="1">attrs = append(attrs, scAttr)</span>
        }

        <span class="cov8" title="138">return attrs, nil</span>
}

// sortAttributes sorts attributes by their DER encoding for SET OF compliance.
func sortAttributes(attrs []Attribute) ([]Attribute, error) <span class="cov8" title="138">{
        type attrWithEncoding struct {
                attr    Attribute
                encoded []byte
        }

        items := make([]attrWithEncoding, len(attrs))
        for i, attr := range attrs </span><span class="cov9" title="415">{
                encoded, err := asn1.Marshal(attr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov9" title="415">items[i] = attrWithEncoding{attr: attr, encoded: encoded}</span>
        }

        <span class="cov8" title="138">sort.Slice(items, func(i, j int) bool </span><span class="cov9" title="415">{
                return bytes.Compare(items[i].encoded, items[j].encoded) &lt; 0
        }</span>)

        <span class="cov8" title="138">result := make([]Attribute, len(attrs))
        for i, item := range items </span><span class="cov9" title="415">{
                result[i] = item.attr
        }</span>
        <span class="cov8" title="138">return result, nil</span>
}

func computeDigest(data []byte, alg crypto.Hash) ([]byte, error) <span class="cov9" title="359">{
        var h hash.Hash
        switch alg </span>{
        case crypto.SHA256:<span class="cov8" title="224">
                h = sha256.New()</span>
        case crypto.SHA384:<span class="cov6" title="41">
                h = sha512.New384()</span>
        case crypto.SHA512:<span class="cov7" title="72">
                h = sha512.New()</span>
        case crypto.SHA3_256:<span class="cov3" title="7">
                h = sha3.New256()</span>
        case crypto.SHA3_384:<span class="cov3" title="7">
                h = sha3.New384()</span>
        case crypto.SHA3_512:<span class="cov3" title="7">
                h = sha3.New512()</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported digest algorithm: %v", alg)</span>
        }
        <span class="cov9" title="358">h.Write(data)
        return h.Sum(nil), nil</span>
}

// computeSHAKE256 computes a SHAKE256 digest with the specified output length.
// SHAKE256 is an extendable output function (XOF) recommended by RFC 9882.
// For CMS usage, outputLen should typically be 64 (512 bits) to match SHA-512 security.
func computeSHAKE256(data []byte, outputLen int) []byte <span class="cov4" title="9">{
        h := sha3.NewShake256()
        h.Write(data)
        out := make([]byte, outputLen)
        _, _ = h.Read(out) // ShakeHash.Read never returns an error
        return out
}</span>

// signDataWithCert signs data using the appropriate signature format based on the certificate type.
// The CERTIFICATE dictates the signature format:
// - Catalyst: classical signature only (primary key is classical)
// - Composite: composite signature (ML-DSA + ECDSA combined)
// - PQC: pure PQC signature (ML-DSA or SLH-DSA)
// - Classical: classical signature (ECDSA, RSA, Ed25519)
func signDataWithCert(data []byte, signer crypto.Signer, digestAlg crypto.Hash, cert *x509.Certificate) ([]byte, error) <span class="cov8" title="147">{
        certType := x509util.GetCertificateType(cert)

        switch certType </span>{
        case x509util.CertTypeCatalyst:<span class="cov0" title="0">
                // Catalyst: use classical signature only
                if hybridSigner, ok := signer.(pkicrypto.HybridSigner); ok </span><span class="cov0" title="0">{
                        classical := hybridSigner.ClassicalSigner()
                        digest, err := computeDigest(data, digestAlg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return classical.Sign(rand.Reader, digest, digestAlg)</span>
                }
                // Not a hybrid signer, fall through to classical
                <span class="cov0" title="0">return signClassical(data, signer, digestAlg)</span>

        case x509util.CertTypeComposite:<span class="cov4" title="13">
                // Composite: use composite signature (both algorithms)
                if hybridSigner, ok := signer.(pkicrypto.HybridSigner); ok </span><span class="cov4" title="12">{
                        sig, err := signComposite(data, hybridSigner)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("composite signature failed: %w", err)
                        }</span>
                        <span class="cov4" title="12">return sig, nil</span>
                }
                <span class="cov1" title="1">return nil, fmt.Errorf("composite certificate requires HybridSigner")</span>

        case x509util.CertTypePQC:<span class="cov6" title="66">
                // PQC: sign data directly (pure mode per RFC 9882)
                return signer.Sign(rand.Reader, data, crypto.Hash(0))</span>

        default:<span class="cov7" title="68">
                // Classical: standard signature
                return signClassical(data, signer, digestAlg)</span>
        }
}

// signClassical performs a classical signature (ECDSA, RSA, Ed25519, Ed448).
func signClassical(data []byte, signer crypto.Signer, digestAlg crypto.Hash) ([]byte, error) <span class="cov7" title="71">{
        // For Ed25519, sign the data directly (no digest)
        if _, ok := signer.Public().(ed25519.PublicKey); ok </span><span class="cov3" title="7">{
                return signer.Sign(rand.Reader, data, crypto.Hash(0))
        }</span>

        // For Ed448, sign the data directly with empty context (RFC 8419 pure mode)
        <span class="cov6" title="64">if _, ok := signer.Public().(ed448.PublicKey); ok </span><span class="cov4" title="10">{
                return signer.Sign(rand.Reader, data, crypto.Hash(0))
        }</span>

        // For ECDSA and RSA, compute digest first
        <span class="cov6" title="54">digest, err := computeDigest(data, digestAlg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="54">return signer.Sign(rand.Reader, digest, digestAlg)</span>
}

// signComposite creates a Composite signature using both classical and PQC signers.
// Returns an error if the algorithm combination is not a valid Composite algorithm
// (e.g., Catalyst uses P-384 + ML-DSA-65 which is not a Composite combination).
func signComposite(data []byte, hybridSigner pkicrypto.HybridSigner) ([]byte, error) <span class="cov5" title="18">{
        classical := hybridSigner.ClassicalSigner()
        pqc := hybridSigner.PQCSigner()

        // Get the composite algorithm based on the signer algorithms
        compAlg, err := ca.GetCompositeAlgorithm(classical.Algorithm(), pqc.Algorithm())
        if err != nil </span><span class="cov1" title="1">{
                return nil, err // Not a valid Composite combination
        }</span>

        // Create Composite signature using the CA package
        <span class="cov5" title="17">return ca.CreateCompositeSignature(data, compAlg, pqc, classical)</span>
}

func getDigestAlgorithmIdentifier(alg crypto.Hash) pkix.AlgorithmIdentifier <span class="cov8" title="150">{
        switch alg </span>{
        case crypto.SHA256:<span class="cov7" title="88">
                return pkix.AlgorithmIdentifier{Algorithm: OIDSHA256}</span>
        case crypto.SHA384:<span class="cov4" title="16">
                return pkix.AlgorithmIdentifier{Algorithm: OIDSHA384}</span>
        case crypto.SHA512:<span class="cov6" title="36">
                return pkix.AlgorithmIdentifier{Algorithm: OIDSHA512}</span>
        case crypto.SHA3_256:<span class="cov2" title="3">
                return pkix.AlgorithmIdentifier{Algorithm: OIDSHA3_256}</span>
        case crypto.SHA3_384:<span class="cov2" title="3">
                return pkix.AlgorithmIdentifier{Algorithm: OIDSHA3_384}</span>
        case crypto.SHA3_512:<span class="cov2" title="3">
                return pkix.AlgorithmIdentifier{Algorithm: OIDSHA3_512}</span>
        default:<span class="cov1" title="1">
                return pkix.AlgorithmIdentifier{Algorithm: OIDSHA256}</span>
        }
}

// getSignatureAlgorithmIdentifierWithCert returns the signature algorithm OID based on certificate type.
// The CERTIFICATE dictates the algorithm:
// - Catalyst: classical algorithm (ECDSA, RSA)
// - Composite: composite algorithm OID
// - PQC: PQC algorithm (ML-DSA, SLH-DSA)
// - Classical: classical algorithm
func getSignatureAlgorithmIdentifierWithCert(signer crypto.Signer, digestAlg crypto.Hash, cert *x509.Certificate) (pkix.AlgorithmIdentifier, error) <span class="cov8" title="142">{
        certType := x509util.GetCertificateType(cert)

        switch certType </span>{
        case x509util.CertTypeCatalyst:<span class="cov0" title="0">
                // Catalyst: use classical algorithm only
                if hybridSigner, ok := signer.(pkicrypto.HybridSigner); ok </span><span class="cov0" title="0">{
                        classical := hybridSigner.ClassicalSigner()
                        return getClassicalSignatureAlgorithmIdentifier(classical.Public(), digestAlg)
                }</span>
                <span class="cov0" title="0">return getClassicalSignatureAlgorithmIdentifier(signer.Public(), digestAlg)</span>

        case x509util.CertTypeComposite:<span class="cov4" title="16">
                // Composite: use composite algorithm OID
                if hybridSigner, ok := signer.(pkicrypto.HybridSigner); ok </span><span class="cov4" title="15">{
                        classical := hybridSigner.ClassicalSigner()
                        pqc := hybridSigner.PQCSigner()
                        compAlg, err := ca.GetCompositeAlgorithm(classical.Algorithm(), pqc.Algorithm())
                        if err != nil </span><span class="cov0" title="0">{
                                return pkix.AlgorithmIdentifier{}, fmt.Errorf("failed to get composite algorithm: %w", err)
                        }</span>
                        <span class="cov4" title="15">return pkix.AlgorithmIdentifier{Algorithm: compAlg.OID}, nil</span>
                }
                <span class="cov1" title="1">return pkix.AlgorithmIdentifier{}, fmt.Errorf("composite certificate requires HybridSigner")</span>

        case x509util.CertTypePQC:<span class="cov6" title="61">
                // PQC: use PQC algorithm
                return detectPQCAlgorithm(signer.Public())</span>

        default:<span class="cov6" title="65">
                // Classical: use classical algorithm
                return getClassicalSignatureAlgorithmIdentifier(signer.Public(), digestAlg)</span>
        }
}

// getSignatureAlgorithmIdentifier is the legacy function for backward compatibility.
// Prefer getSignatureAlgorithmIdentifierWithCert when certificate is available.
func getSignatureAlgorithmIdentifier(signer crypto.Signer, digestAlg crypto.Hash) (pkix.AlgorithmIdentifier, error) <span class="cov2" title="4">{
        // Check for HybridSigner (Composite)
        if hybridSigner, ok := signer.(pkicrypto.HybridSigner); ok </span><span class="cov0" title="0">{
                classical := hybridSigner.ClassicalSigner()
                pqc := hybridSigner.PQCSigner()
                compAlg, err := ca.GetCompositeAlgorithm(classical.Algorithm(), pqc.Algorithm())
                if err == nil </span><span class="cov0" title="0">{
                        return pkix.AlgorithmIdentifier{Algorithm: compAlg.OID}, nil
                }</span>
                // Not a valid Composite combination (e.g., Catalyst uses P-384 + ML-DSA-65)
                // Fall back to classical signature algorithm
                <span class="cov0" title="0">return getClassicalSignatureAlgorithmIdentifier(classical.Public(), digestAlg)</span>
        }

        <span class="cov2" title="4">switch pub := signer.Public().(type) </span>{
        case *ecdsa.PublicKey:<span class="cov1" title="1">
                switch digestAlg </span>{
                case crypto.SHA256:<span class="cov1" title="1">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDECDSAWithSHA256}, nil</span>
                case crypto.SHA384:<span class="cov0" title="0">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDECDSAWithSHA384}, nil</span>
                case crypto.SHA512:<span class="cov0" title="0">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDECDSAWithSHA512}, nil</span>
                default:<span class="cov0" title="0">
                        return pkix.AlgorithmIdentifier{}, fmt.Errorf("unsupported ECDSA digest: %v", digestAlg)</span>
                }
        case ed25519.PublicKey:<span class="cov1" title="1">
                return pkix.AlgorithmIdentifier{Algorithm: OIDEd25519}, nil</span>
        case ed448.PublicKey:<span class="cov1" title="1">
                return pkix.AlgorithmIdentifier{Algorithm: OIDEd448}, nil</span>
        case *rsa.PublicKey:<span class="cov1" title="1">
                switch digestAlg </span>{
                case crypto.SHA256:<span class="cov1" title="1">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDSHA256WithRSA}, nil</span>
                case crypto.SHA384:<span class="cov0" title="0">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDSHA384WithRSA}, nil</span>
                case crypto.SHA512:<span class="cov0" title="0">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDSHA512WithRSA}, nil</span>
                default:<span class="cov0" title="0">
                        return pkix.AlgorithmIdentifier{}, fmt.Errorf("unsupported RSA digest: %v", digestAlg)</span>
                }
        default:<span class="cov0" title="0">
                // Try to detect PQC algorithms by examining the public key
                // This is a placeholder - actual implementation depends on the crypto package
                return detectPQCAlgorithm(pub)</span>
        }
}

// getClassicalSignatureAlgorithmIdentifier returns the algorithm identifier for classical signatures.
// Used for Catalyst fallback when Composite is not applicable.
func getClassicalSignatureAlgorithmIdentifier(pub crypto.PublicKey, digestAlg crypto.Hash) (pkix.AlgorithmIdentifier, error) <span class="cov7" title="75">{
        switch pub.(type) </span>{
        case *ecdsa.PublicKey:<span class="cov6" title="44">
                switch digestAlg </span>{
                case crypto.SHA256:<span class="cov6" title="34">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDECDSAWithSHA256}, nil</span>
                case crypto.SHA384:<span class="cov3" title="6">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDECDSAWithSHA384}, nil</span>
                case crypto.SHA512:<span class="cov2" title="3">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDECDSAWithSHA512}, nil</span>
                default:<span class="cov1" title="1">
                        return pkix.AlgorithmIdentifier{}, fmt.Errorf("unsupported ECDSA digest: %v", digestAlg)</span>
                }
        case *rsa.PublicKey:<span class="cov4" title="14">
                switch digestAlg </span>{
                case crypto.SHA256:<span class="cov3" title="8">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDSHA256WithRSA}, nil</span>
                case crypto.SHA384:<span class="cov2" title="3">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDSHA384WithRSA}, nil</span>
                case crypto.SHA512:<span class="cov1" title="2">
                        return pkix.AlgorithmIdentifier{Algorithm: OIDSHA512WithRSA}, nil</span>
                default:<span class="cov1" title="1">
                        return pkix.AlgorithmIdentifier{}, fmt.Errorf("unsupported RSA digest: %v", digestAlg)</span>
                }
        case ed25519.PublicKey:<span class="cov3" title="6">
                return pkix.AlgorithmIdentifier{Algorithm: OIDEd25519}, nil</span>
        case ed448.PublicKey:<span class="cov4" title="10">
                return pkix.AlgorithmIdentifier{Algorithm: OIDEd448}, nil</span>
        default:<span class="cov1" title="1">
                return pkix.AlgorithmIdentifier{}, fmt.Errorf("unsupported classical public key type: %T", pub)</span>
        }
}

func detectPQCAlgorithm(pub interface{}) (pkix.AlgorithmIdentifier, error) <span class="cov6" title="67">{
        // Use AlgorithmFromPublicKey for robust algorithm detection
        alg := pkicrypto.AlgorithmFromPublicKey(pub)
        if alg == pkicrypto.AlgUnknown </span><span class="cov0" title="0">{
                return pkix.AlgorithmIdentifier{}, fmt.Errorf("unsupported public key type: %T", pub)
        }</span>

        // Map AlgorithmID to OID
        <span class="cov6" title="67">oid := algorithmIDToOID(alg)
        if oid == nil </span><span class="cov1" title="1">{
                return pkix.AlgorithmIdentifier{}, fmt.Errorf("no OID for algorithm: %s", alg)
        }</span>

        <span class="cov6" title="66">return pkix.AlgorithmIdentifier{Algorithm: oid}, nil</span>
}

// algorithmIDToOID maps AlgorithmID to ASN.1 OID for signature algorithms.
func algorithmIDToOID(alg pkicrypto.AlgorithmID) asn1.ObjectIdentifier <span class="cov7" title="90">{
        switch alg </span>{
        // ML-DSA
        case pkicrypto.AlgMLDSA44:<span class="cov4" title="9">
                return OIDMLDSA44</span>
        case pkicrypto.AlgMLDSA65:<span class="cov4" title="10">
                return OIDMLDSA65</span>
        case pkicrypto.AlgMLDSA87:<span class="cov4" title="9">
                return OIDMLDSA87</span>
        // SLH-DSA SHA2 variants
        case pkicrypto.AlgSLHDSASHA2128s:<span class="cov3" title="6">
                return OIDSLHDSASHA2128s</span>
        case pkicrypto.AlgSLHDSASHA2128f:<span class="cov4" title="15">
                return OIDSLHDSASHA2128f</span>
        case pkicrypto.AlgSLHDSASHA2192s:<span class="cov2" title="3">
                return OIDSLHDSASHA2192s</span>
        case pkicrypto.AlgSLHDSASHA2192f:<span class="cov3" title="5">
                return OIDSLHDSASHA2192f</span>
        case pkicrypto.AlgSLHDSASHA2256s:<span class="cov2" title="3">
                return OIDSLHDSASHA2256s</span>
        case pkicrypto.AlgSLHDSASHA2256f:<span class="cov3" title="6">
                return OIDSLHDSASHA2256f</span>
        // SLH-DSA SHAKE variants
        case pkicrypto.AlgSLHDSASHAKE128s:<span class="cov1" title="2">
                return OIDSLHDSASHAKE128s</span>
        case pkicrypto.AlgSLHDSASHAKE128f:<span class="cov3" title="8">
                return OIDSLHDSASHAKE128f</span>
        case pkicrypto.AlgSLHDSASHAKE192s:<span class="cov1" title="2">
                return OIDSLHDSASHAKE192s</span>
        case pkicrypto.AlgSLHDSASHAKE192f:<span class="cov2" title="3">
                return OIDSLHDSASHAKE192f</span>
        case pkicrypto.AlgSLHDSASHAKE256s:<span class="cov1" title="2">
                return OIDSLHDSASHAKE256s</span>
        case pkicrypto.AlgSLHDSASHAKE256f:<span class="cov2" title="4">
                return OIDSLHDSASHAKE256f</span>
        default:<span class="cov2" title="3">
                return nil</span>
        }
}

// injectCertificates injects a certificate into a SignedData structure.
// This is needed because Go's asn1 package doesn't properly handle the
// IMPLICIT [0] tag for the certificates field.
func injectCertificates(signedDataDER []byte, certDER []byte) ([]byte, error) <span class="cov8" title="140">{
        // Parse the SignedData to find where to inject
        // SignedData ::= SEQUENCE {
        //   version CMSVersion,
        //   digestAlgorithms DigestAlgorithmIdentifiers,
        //   encapContentInfo EncapsulatedContentInfo,
        //   certificates [0] IMPLICIT CertificateSet OPTIONAL,  &lt;- inject here
        //   crls [1] IMPLICIT RevocationInfoChoices OPTIONAL,
        //   signerInfos SignerInfos }

        // Build the certificates field: IMPLICIT [0] containing the certificate
        // Tag 0xA0 = context-specific, constructed, tag 0
        certField := make([]byte, 0, len(certDER)+4)
        certField = append(certField, 0xA0) // IMPLICIT [0] tag

        // Encode length
        certLen := len(certDER)
        if certLen &lt; 128 </span><span class="cov2" title="3">{
                certField = append(certField, byte(certLen))
        }</span> else<span class="cov8" title="137"> if certLen &lt; 256 </span><span class="cov0" title="0">{
                certField = append(certField, 0x81, byte(certLen))
        }</span> else<span class="cov8" title="137"> {
                certField = append(certField, 0x82, byte(certLen&gt;&gt;8), byte(certLen))
        }</span>
        <span class="cov8" title="140">certField = append(certField, certDER...)

        // Parse SignedData to find injection point (after encapContentInfo, before signerInfos)
        // For simplicity, we'll rebuild the SEQUENCE with the certificates inserted
        if len(signedDataDER) &lt; 2 </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("invalid SignedData: too short")
        }</span>

        // Get the total length and find where to insert
        // The SignedData SEQUENCE tag is 0x30
        <span class="cov8" title="138">if signedDataDER[0] != 0x30 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid SignedData: expected SEQUENCE")
        }</span>

        // Calculate new total length
        <span class="cov8" title="137">_, contentStart := parseASN1Length(signedDataDER[1:])
        contentStart++ // account for the tag byte

        // New content = old content + certificates field
        newContent := make([]byte, 0, len(signedDataDER)+len(certField))
        oldContent := signedDataDER[contentStart:]

        // Find the signerInfos SET (last element) - it starts with 0x31
        // We need to insert certificates before it
        insertPos := findSignerInfosPosition(oldContent)
        if insertPos &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not find signerInfos in SignedData")
        }</span>

        <span class="cov8" title="137">newContent = append(newContent, oldContent[:insertPos]...)
        newContent = append(newContent, certField...)
        newContent = append(newContent, oldContent[insertPos:]...)

        // Build new SignedData with updated length
        result := make([]byte, 0, len(newContent)+4)
        result = append(result, 0x30) // SEQUENCE tag

        // Encode new length
        newLen := len(newContent)
        if newLen &lt; 128 </span><span class="cov0" title="0">{
                result = append(result, byte(newLen))
        }</span> else<span class="cov8" title="137"> if newLen &lt; 256 </span><span class="cov0" title="0">{
                result = append(result, 0x81, byte(newLen))
        }</span> else<span class="cov8" title="137"> if newLen &lt; 65536 </span><span class="cov7" title="122">{
                result = append(result, 0x82, byte(newLen&gt;&gt;8), byte(newLen))
        }</span> else<span class="cov4" title="15"> {
                result = append(result, 0x83, byte(newLen&gt;&gt;16), byte(newLen&gt;&gt;8), byte(newLen))
        }</span>
        <span class="cov8" title="137">result = append(result, newContent...)

        return result, nil</span>
}

// parseASN1Length parses an ASN.1 length and returns the length value and bytes consumed.
func parseASN1Length(data []byte) (int, int) <span class="cov10" title="555">{
        if len(data) == 0 </span><span class="cov1" title="1">{
                return 0, 0
        }</span>
        <span class="cov9" title="554">if data[0] &lt; 128 </span><span class="cov9" title="411">{
                return int(data[0]), 1
        }</span>
        <span class="cov8" title="143">numBytes := int(data[0] &amp; 0x7f)
        if numBytes &gt; len(data)-1 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>
        <span class="cov8" title="143">length := 0
        for i := 0; i &lt; numBytes; i++ </span><span class="cov9" title="290">{
                length = length&lt;&lt;8 | int(data[1+i])
        }</span>
        <span class="cov8" title="143">return length, numBytes + 1</span>
}

// findSignerInfosPosition finds the position of the signerInfos SET in SignedData content.
// SignedData structure:
//
//        version           INTEGER
//        digestAlgorithms  SET OF (tag 0x31)
//        encapContentInfo  SEQUENCE (tag 0x30)
//        certificates      [0] IMPLICIT OPTIONAL (tag 0xA0)
//        crls              [1] IMPLICIT OPTIONAL (tag 0xA1)
//        signerInfos       SET OF (tag 0x31)
//
// We need to find the signerInfos SET, which is the last element.
func findSignerInfosPosition(content []byte) int <span class="cov8" title="137">{
        pos := 0

        // 1. Skip version (INTEGER, tag 0x02)
        if pos &gt;= len(content) || content[pos] != 0x02 </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="137">pos++
        length, lenBytes := parseASN1Length(content[pos:])
        pos += lenBytes + length

        // 2. Skip digestAlgorithms (SET, tag 0x31)
        if pos &gt;= len(content) || content[pos] != 0x31 </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="137">pos++
        length, lenBytes = parseASN1Length(content[pos:])
        pos += lenBytes + length

        // 3. Skip encapContentInfo (SEQUENCE, tag 0x30)
        if pos &gt;= len(content) || content[pos] != 0x30 </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="137">pos++
        length, lenBytes = parseASN1Length(content[pos:])
        pos += lenBytes + length

        // 4. Skip certificates [0] IMPLICIT if present (tag 0xA0)
        if pos &lt; len(content) &amp;&amp; content[pos] == 0xA0 </span><span class="cov0" title="0">{
                pos++
                length, lenBytes = parseASN1Length(content[pos:])
                pos += lenBytes + length
        }</span>

        // 5. Skip crls [1] IMPLICIT if present (tag 0xA1)
        <span class="cov8" title="137">if pos &lt; len(content) &amp;&amp; content[pos] == 0xA1 </span><span class="cov0" title="0">{
                pos++
                length, lenBytes = parseASN1Length(content[pos:])
                pos += lenBytes + length
        }</span>

        // 6. signerInfos (SET, tag 0x31) should be here
        <span class="cov8" title="137">if pos &gt;= len(content) || content[pos] != 0x31 </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov8" title="137">return pos</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cms

import (
        "bytes"
        "context"
        "crypto"
        "crypto/ecdsa"
        "crypto/ed25519"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/asn1"
        "fmt"
        "strings"
        "time"

        "github.com/cloudflare/circl/sign/ed448"
        "github.com/remiblancher/post-quantum-pki/internal/ca"
        pkicrypto "github.com/remiblancher/post-quantum-pki/internal/crypto"
        "github.com/remiblancher/post-quantum-pki/internal/x509util"
)

// VerifyConfig contains options for verifying a CMS signature.
type VerifyConfig struct {
        // Roots is the pool of trusted CA certificates
        Roots *x509.CertPool
        // Intermediates is the pool of intermediate CA certificates
        Intermediates *x509.CertPool
        // CurrentTime is the time to use for verification (default: now)
        CurrentTime time.Time
        // Data is the original data for detached signatures
        Data []byte
        // SkipCertVerify skips certificate chain verification
        SkipCertVerify bool
        // RootCertRaw is the raw DER-encoded root CA certificate for PQC verification
        // This is needed because Go's x509 package doesn't support PQC signatures
        RootCertRaw []byte
}

// VerifyResult contains the result of signature verification.
type VerifyResult struct {
        // SignerCert is the certificate that signed the content
        SignerCert *x509.Certificate
        // Content is the signed content (nil for detached signatures)
        Content []byte
        // SigningTime is the signing time from signed attributes (if present)
        SigningTime time.Time
        // ContentType is the content type OID
        ContentType asn1.ObjectIdentifier
        // Warnings contains non-fatal warnings (e.g., RFC compliance recommendations)
        Warnings []string
}

// checkDigestSecurityLevel checks if the digest algorithm provides adequate security
// for the signature algorithm per RFC 9882 recommendations.
// Returns a warning message if the combination is suboptimal, empty string otherwise.
func checkDigestSecurityLevel(sigAlgOID asn1.ObjectIdentifier, digestAlg crypto.Hash) string <span class="cov8" title="160">{
        // RFC 9882: ML-DSA digest security level recommendations
        if sigAlgOID.Equal(OIDMLDSA87) &amp;&amp; digestAlg != crypto.SHA512 </span><span class="cov3" title="7">{
                return fmt.Sprintf("ML-DSA-87 signature uses %s (RFC 9882 recommends SHA-512 for NIST Level 5)", digestAlg)
        }</span>
        <span class="cov8" title="153">if sigAlgOID.Equal(OIDMLDSA65) &amp;&amp; digestAlg != crypto.SHA384 &amp;&amp; digestAlg != crypto.SHA512 </span><span class="cov3" title="5">{
                return fmt.Sprintf("ML-DSA-65 signature uses %s (RFC 9882 recommends SHA-384 or SHA-512 for NIST Level 3)", digestAlg)
        }</span>
        <span class="cov8" title="148">return ""</span>
}

// Verify verifies a CMS SignedData signature.
func Verify(ctx context.Context, signedDataDER []byte, config *VerifyConfig) (*VerifyResult, error) <span class="cov8" title="128">{
        _ = ctx // TODO: use for cancellation
        if config == nil </span><span class="cov3" title="6">{
                config = &amp;VerifyConfig{}
        }</span>

        // Parse ContentInfo
        <span class="cov8" title="128">var contentInfo ContentInfo
        _, err := asn1.Unmarshal(signedDataDER, &amp;contentInfo)
        if err != nil </span><span class="cov3" title="6">{
                return nil, fmt.Errorf("failed to parse ContentInfo: %w", err)
        }</span>

        <span class="cov8" title="122">if !contentInfo.ContentType.Equal(OIDSignedData) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a SignedData structure, got OID %v", contentInfo.ContentType)
        }</span>

        // Parse SignedData
        <span class="cov8" title="122">var signedData SignedData
        _, err = asn1.Unmarshal(contentInfo.Content.Bytes, &amp;signedData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse SignedData: %w", err)
        }</span>

        // Extract signer certificate
        <span class="cov8" title="122">signerCert, err := extractSignerCert(&amp;signedData, config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to extract signer certificate: %w", err)
        }</span>

        // Verify the certificate chain (unless skipped)
        <span class="cov8" title="121">if !config.SkipCertVerify &amp;&amp; config.Roots != nil </span><span class="cov2" title="2">{
                if err := verifyCertChain(signerCert, config); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("certificate chain verification failed: %w", err)
                }</span>
        }

        // Verify signature
        <span class="cov8" title="120">if len(signedData.SignerInfos) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no signer info in SignedData")
        }</span>

        <span class="cov8" title="120">signerInfo := signedData.SignerInfos[0]

        // Get content for verification
        content := getContent(&amp;signedData, config)

        if err := verifySignature(&amp;signedData, &amp;signerInfo, signerCert, content); err != nil </span><span class="cov5" title="17">{
                return nil, fmt.Errorf("signature verification failed: %w", err)
        }</span>

        // Get digest algorithm for RFC 9882 compliance check
        <span class="cov8" title="103">hashAlg, _ := oidToHash(signerInfo.DigestAlgorithm.Algorithm)

        result := &amp;VerifyResult{
                SignerCert:  signerCert,
                ContentType: signedData.EncapContentInfo.EContentType,
        }

        // Check RFC 9882 digest security level recommendation
        if warning := checkDigestSecurityLevel(signerInfo.SignatureAlgorithm.Algorithm, hashAlg); warning != "" </span><span class="cov3" title="5">{
                result.Warnings = append(result.Warnings, warning)
        }</span>

        // Extract content if present
        <span class="cov8" title="103">if signedData.EncapContentInfo.EContent.Bytes != nil </span><span class="cov7" title="93">{
                if signedData.EncapContentInfo.EContent.Tag == asn1.TagOctetString </span><span class="cov0" title="0">{
                        result.Content = signedData.EncapContentInfo.EContent.Bytes
                }</span> else<span class="cov7" title="93"> {
                        var content []byte
                        _, err := asn1.Unmarshal(signedData.EncapContentInfo.EContent.Bytes, &amp;content)
                        if err == nil </span><span class="cov7" title="93">{
                                result.Content = content
                        }</span> else<span class="cov0" title="0"> {
                                result.Content = signedData.EncapContentInfo.EContent.Bytes
                        }</span>
                }
        }

        // Extract signing time from signed attributes
        <span class="cov8" title="103">result.SigningTime = extractSigningTime(signerInfo.SignedAttrs)

        return result, nil</span>
}

// getContent returns the content to verify (from SignedData or config for detached).
func getContent(signedData *SignedData, config *VerifyConfig) []byte <span class="cov8" title="123">{
        // For detached signatures, use provided data
        if len(config.Data) &gt; 0 </span><span class="cov4" title="13">{
                return config.Data
        }</span>

        // Extract from encapsulated content
        <span class="cov8" title="110">if signedData.EncapContentInfo.EContent.Tag == asn1.TagOctetString </span><span class="cov1" title="1">{
                return signedData.EncapContentInfo.EContent.Bytes
        }</span>

        // Try to unmarshal as OCTET STRING
        <span class="cov8" title="109">var content []byte
        _, err := asn1.Unmarshal(signedData.EncapContentInfo.EContent.Bytes, &amp;content)
        if err == nil </span><span class="cov8" title="109">{
                return content
        }</span>

        <span class="cov0" title="0">return signedData.EncapContentInfo.EContent.Bytes</span>
}

// extractSignerCert extracts the signer certificate from SignedData or config.
func extractSignerCert(signedData *SignedData, config *VerifyConfig) (*x509.Certificate, error) <span class="cov8" title="122">{
        // Try to extract from embedded certificates
        if len(signedData.Certificates.Raw) &gt; 0 </span><span class="cov8" title="121">{
                // The Raw field contains [0] IMPLICIT wrapped certificates
                // We need to parse it as a RawValue to get the inner bytes
                var rawVal asn1.RawValue
                _, err := asn1.Unmarshal(signedData.Certificates.Raw, &amp;rawVal)
                if err == nil &amp;&amp; len(rawVal.Bytes) &gt; 0 </span><span class="cov8" title="121">{
                        certs, err := parseCertificates(rawVal.Bytes)
                        if err == nil &amp;&amp; len(certs) &gt; 0 </span><span class="cov8" title="121">{
                                return certs[0], nil
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil, fmt.Errorf("no signer certificate found in SignedData")</span>
}

// parseCertificates parses the raw certificates from CMS.
func parseCertificates(raw []byte) ([]*x509.Certificate, error) <span class="cov8" title="127">{
        var certs []*x509.Certificate
        for len(raw) &gt; 0 </span><span class="cov8" title="126">{
                cert, err := x509.ParseCertificate(raw)
                if err != nil </span><span class="cov2" title="2">{
                        // Try to parse as a sequence of certificates
                        var certData asn1.RawValue
                        rest, err := asn1.Unmarshal(raw, &amp;certData)
                        if err != nil </span><span class="cov2" title="2">{
                                break</span>
                        }
                        <span class="cov0" title="0">cert, err = x509.ParseCertificate(certData.FullBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                raw = rest
                                continue</span>
                        }
                        <span class="cov0" title="0">raw = rest</span>
                } else<span class="cov8" title="124"> {
                        raw = nil
                }</span>
                <span class="cov8" title="124">certs = append(certs, cert)</span>
        }
        <span class="cov8" title="127">if len(certs) == 0 </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("no certificates found")
        }</span>
        <span class="cov8" title="124">return certs, nil</span>
}

// verifyCertChain verifies the certificate chain.
func verifyCertChain(cert *x509.Certificate, config *VerifyConfig) error <span class="cov4" title="10">{
        opts := x509.VerifyOptions{
                Roots:         config.Roots,
                Intermediates: config.Intermediates,
        }
        if !config.CurrentTime.IsZero() </span><span class="cov2" title="2">{
                opts.CurrentTime = config.CurrentTime
        }</span>

        <span class="cov4" title="10">_, err := cert.Verify(opts)
        if err == nil </span><span class="cov3" title="5">{
                return nil
        }</span>

        // If Go's x509 fails with "unknown authority", try PQC/Composite verification
        // This happens when the CA uses a PQC algorithm that Go doesn't support
        <span class="cov3" title="5">if strings.Contains(err.Error(), "unknown authority") &amp;&amp; len(config.RootCertRaw) &gt; 0 </span><span class="cov0" title="0">{
                // Parse the root certificate (Go parses structure but PublicKey may be nil for PQC)
                rootCert, parseErr := x509.ParseCertificate(config.RootCertRaw)
                if parseErr == nil </span><span class="cov0" title="0">{
                        // Extract signature algorithm OID from the certificate being verified
                        sigAlgOID, extractErr := x509util.ExtractSignatureAlgorithmOID(cert.Raw)
                        if extractErr == nil &amp;&amp; x509util.IsCompositeOID(sigAlgOID) </span><span class="cov0" title="0">{
                                // Use Composite certificate verification
                                result, compErr := ca.VerifyCompositeCertificate(cert, rootCert)
                                if compErr == nil &amp;&amp; result.Valid </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Use PQC certificate verification for pure PQC algorithms
                                valid, pqcErr := ca.VerifyPQCCertificateRaw(cert.Raw, rootCert)
                                if pqcErr == nil &amp;&amp; valid </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        }
                }
        }

        <span class="cov3" title="5">return err</span>
}

// verifySignature verifies the CMS signature.
func verifySignature(signedData *SignedData, signerInfo *SignerInfo, cert *x509.Certificate, content []byte) error <span class="cov8" title="120">{
        // Determine the hash algorithm
        hashAlg, err := oidToHash(signerInfo.DigestAlgorithm.Algorithm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If signed attributes exist, verify they contain the correct message digest
        <span class="cov8" title="120">if len(signerInfo.SignedAttrs) &gt; 0 </span><span class="cov8" title="120">{
                // Compute content digest
                contentDigest, err := computeDigest(content, hashAlg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to compute content digest: %w", err)
                }</span>

                // Find and verify message digest attribute
                <span class="cov8" title="120">found := false
                for _, attr := range signerInfo.SignedAttrs </span><span class="cov10" title="360">{
                        if attr.Type.Equal(OIDMessageDigest) &amp;&amp; len(attr.Values) &gt; 0 </span><span class="cov8" title="120">{
                                var md []byte
                                _, err := asn1.Unmarshal(attr.Values[0].FullBytes, &amp;md)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to parse message digest: %w", err)
                                }</span>
                                <span class="cov8" title="120">if !bytes.Equal(md, contentDigest) </span><span class="cov3" title="5">{
                                        return fmt.Errorf("message digest mismatch")
                                }</span>
                                <span class="cov8" title="115">found = true
                                break</span>
                        }
                }
                <span class="cov8" title="115">if !found </span><span class="cov0" title="0">{
                        return fmt.Errorf("no message digest attribute found")
                }</span>

                // Marshal signed attributes for signature verification
                <span class="cov8" title="115">signedAttrsDER, err := MarshalSignedAttrs(signerInfo.SignedAttrs)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal signed attributes: %w", err)
                }</span>

                <span class="cov8" title="115">return verifySignatureBytes(signedAttrsDER, signerInfo.Signature, cert, hashAlg, signerInfo.SignatureAlgorithm.Algorithm)</span>
        }

        // No signed attributes - verify signature over content directly
        <span class="cov0" title="0">return verifySignatureBytes(content, signerInfo.Signature, cert, hashAlg, signerInfo.SignatureAlgorithm.Algorithm)</span>
}

// validateAlgorithmKeyMatch validates that the declared signature algorithm OID
// is compatible with the certificate's public key type.
//
// SECURITY: This is critical to prevent algorithm confusion attacks.
// The algorithm used for verification MUST be determined by the OID,
// not by the Go key type. This function rejects mismatches before any
// cryptographic verification is attempted.
//
// See: CVE-2024-49958 (Linux kernel), CVE-2022-21449 (Java psychic signatures)
func validateAlgorithmKeyMatch(sigAlgOID asn1.ObjectIdentifier, pub crypto.PublicKey, hashAlg crypto.Hash) error <span class="cov6" title="42">{
        switch pub.(type) </span>{
        case *ecdsa.PublicKey:<span class="cov5" title="26">
                return validateECDSAKeyMatch(sigAlgOID, hashAlg)</span>
        case ed25519.PublicKey:<span class="cov3" title="5">
                return validateEd25519KeyMatch(sigAlgOID)</span>
        case ed448.PublicKey:<span class="cov0" title="0">
                return validateEd448KeyMatch(sigAlgOID)</span>
        case *rsa.PublicKey:<span class="cov4" title="10">
                return validateRSAKeyMatch(sigAlgOID, hashAlg)</span>
        default:<span class="cov1" title="1">
                return validatePQCKeyMatch(sigAlgOID, pub)</span>
        }
}

// validateECDSAKeyMatch validates ECDSA OID matches the hash algorithm.
func validateECDSAKeyMatch(sigAlgOID asn1.ObjectIdentifier, hashAlg crypto.Hash) error <span class="cov6" title="31">{
        expectedHash, ok := ecdsaOIDToHash[sigAlgOID.String()]
        if !ok </span><span class="cov3" title="6">{
                return fmt.Errorf("algorithm mismatch: OID %v is not valid for ECDSA key", sigAlgOID)
        }</span>
        <span class="cov5" title="25">if hashAlg != expectedHash </span><span class="cov2" title="2">{
                return fmt.Errorf("algorithm mismatch: ECDSA OID expects %v but hash is %v", expectedHash, hashAlg)
        }</span>
        <span class="cov5" title="23">return nil</span>
}

// validateEd25519KeyMatch validates Ed25519 OID.
func validateEd25519KeyMatch(sigAlgOID asn1.ObjectIdentifier) error <span class="cov4" title="8">{
        if !sigAlgOID.Equal(OIDEd25519) </span><span class="cov2" title="2">{
                return fmt.Errorf("algorithm mismatch: OID %v is not valid for Ed25519 key", sigAlgOID)
        }</span>
        <span class="cov3" title="6">return nil</span>
}

// validateEd448KeyMatch validates Ed448 OID (RFC 8419).
func validateEd448KeyMatch(sigAlgOID asn1.ObjectIdentifier) error <span class="cov3" title="4">{
        if !sigAlgOID.Equal(OIDEd448) </span><span class="cov2" title="3">{
                return fmt.Errorf("algorithm mismatch: OID %v is not valid for Ed448 key", sigAlgOID)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// validateRSAKeyMatch validates RSA OID matches the hash algorithm.
func validateRSAKeyMatch(sigAlgOID asn1.ObjectIdentifier, hashAlg crypto.Hash) error <span class="cov5" title="15">{
        expectedHash, ok := rsaOIDToHash[sigAlgOID.String()]
        if !ok </span><span class="cov2" title="2">{
                return fmt.Errorf("algorithm mismatch: OID %v is not valid for RSA key", sigAlgOID)
        }</span>
        <span class="cov4" title="13">if hashAlg != expectedHash </span><span class="cov1" title="1">{
                return fmt.Errorf("algorithm mismatch: RSA OID expects %v but hash is %v", expectedHash, hashAlg)
        }</span>
        <span class="cov4" title="12">return nil</span>
}

// validatePQCKeyMatch validates PQC OID matches the key type.
func validatePQCKeyMatch(sigAlgOID asn1.ObjectIdentifier, pub crypto.PublicKey) error <span class="cov3" title="5">{
        if err := validateMLDSAKeyMatch(sigAlgOID, pub); err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="4">if isSLHDSAOID(sigAlgOID) </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov2" title="2">return fmt.Errorf("unknown or unsupported signature algorithm OID: %v for key type %T", sigAlgOID, pub)</span>
}

// validateMLDSAKeyMatch validates ML-DSA OID matches the key algorithm.
func validateMLDSAKeyMatch(sigAlgOID asn1.ObjectIdentifier, pub crypto.PublicKey) error <span class="cov4" title="12">{
        keyAlg := pkicrypto.AlgorithmFromPublicKey(pub)
        expectedAlg, ok := mldsaOIDToAlg[sigAlgOID.String()]
        if !ok </span><span class="cov3" title="5">{
                return fmt.Errorf("not an ML-DSA OID")
        }</span>
        <span class="cov3" title="7">if pub != nil &amp;&amp; keyAlg != expectedAlg </span><span class="cov2" title="2">{
                return fmt.Errorf("algorithm mismatch: %s OID but key is %s", expectedAlg, keyAlg)
        }</span>
        <span class="cov3" title="5">return nil</span>
}

// isSLHDSAOID returns true if the OID is a SLH-DSA variant (SHA2 or SHAKE).
func isSLHDSAOID(sigAlgOID asn1.ObjectIdentifier) bool <span class="cov4" title="13">{
        // SHA2 variants
        if sigAlgOID.Equal(OIDSLHDSASHA2128s) || sigAlgOID.Equal(OIDSLHDSASHA2128f) ||
                sigAlgOID.Equal(OIDSLHDSASHA2192s) || sigAlgOID.Equal(OIDSLHDSASHA2192f) ||
                sigAlgOID.Equal(OIDSLHDSASHA2256s) || sigAlgOID.Equal(OIDSLHDSASHA2256f) </span><span class="cov4" title="8">{
                return true
        }</span>
        // SHAKE variants
        <span class="cov3" title="5">return sigAlgOID.Equal(OIDSLHDSASHAKE128s) || sigAlgOID.Equal(OIDSLHDSASHAKE128f) ||
                sigAlgOID.Equal(OIDSLHDSASHAKE192s) || sigAlgOID.Equal(OIDSLHDSASHAKE192f) ||
                sigAlgOID.Equal(OIDSLHDSASHAKE256s) || sigAlgOID.Equal(OIDSLHDSASHAKE256f)</span>
}

// Algorithm lookup tables for validation.
var (
        ecdsaOIDToHash = map[string]crypto.Hash{
                OIDECDSAWithSHA256.String(): crypto.SHA256,
                OIDECDSAWithSHA384.String(): crypto.SHA384,
                OIDECDSAWithSHA512.String(): crypto.SHA512,
        }
        rsaOIDToHash = map[string]crypto.Hash{
                OIDSHA256WithRSA.String(): crypto.SHA256,
                OIDSHA384WithRSA.String(): crypto.SHA384,
                OIDSHA512WithRSA.String(): crypto.SHA512,
        }
        mldsaOIDToAlg = map[string]pkicrypto.AlgorithmID{
                OIDMLDSA44.String(): pkicrypto.AlgMLDSA44,
                OIDMLDSA65.String(): pkicrypto.AlgMLDSA65,
                OIDMLDSA87.String(): pkicrypto.AlgMLDSA87,
        }
)

// verifySignatureBytes verifies a signature over data.
// The CERTIFICATE type dictates the verification method:
// - Catalyst: classical verification only (ignore alternative signature in extension)
// - Composite: composite verification (both ML-DSA + ECDSA)
// - PQC: PQC verification (ML-DSA or SLH-DSA)
// - Classical: classical verification (ECDSA, RSA, Ed25519)
func verifySignatureBytes(data, signature []byte, cert *x509.Certificate, hashAlg crypto.Hash, sigAlgOID asn1.ObjectIdentifier) error <span class="cov8" title="115">{
        // Check certificate type to determine verification method
        certType := x509util.GetCertificateType(cert)

        switch certType </span>{
        case x509util.CertTypeCatalyst:<span class="cov0" title="0">
                // Catalyst: use classical verification only
                // The signature OID should be classical (ECDSA/RSA)
                return verifyClassicalSignature(data, signature, cert, hashAlg, sigAlgOID)</span>

        case x509util.CertTypeComposite:<span class="cov3" title="7">
                // Composite: use composite verification
                if !x509util.IsCompositeOID(sigAlgOID) </span><span class="cov0" title="0">{
                        return fmt.Errorf("composite certificate but signature OID %v is not composite", sigAlgOID)
                }</span>
                <span class="cov3" title="7">return ca.VerifyCompositeSignature(data, signature, cert, sigAlgOID)</span>

        case x509util.CertTypePQC:<span class="cov7" title="58">
                // PQC: use PQC verification
                return verifyPQCSignature(data, signature, cert, sigAlgOID)</span>

        default:<span class="cov6" title="50">
                // Classical: use classical verification
                return verifyClassicalSignature(data, signature, cert, hashAlg, sigAlgOID)</span>
        }
}

// verifyClassicalSignature verifies a classical signature (ECDSA, RSA, Ed25519, Ed448).
func verifyClassicalSignature(data, signature []byte, cert *x509.Certificate, hashAlg crypto.Hash, sigAlgOID asn1.ObjectIdentifier) error <span class="cov6" title="50">{
        pub := cert.PublicKey

        // Handle Ed448 specially: Go's x509 library doesn't support Ed448,
        // so cert.PublicKey will be nil. We need to extract it from RawSubjectPublicKeyInfo.
        if pub == nil &amp;&amp; sigAlgOID.Equal(OIDEd448) </span><span class="cov4" title="8">{
                ed448Pub, err := extractEd448PublicKey(cert)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to extract Ed448 public key: %w", err)
                }</span>
                // Ed448 pure mode verification with empty context (RFC 8419)
                <span class="cov4" title="8">if !ed448.Verify(ed448Pub, data, signature, "") </span><span class="cov1" title="1">{
                        return fmt.Errorf("Ed448 signature verification failed")
                }</span>
                <span class="cov3" title="7">return nil</span>
        }

        // SECURITY: Validate that the declared OID matches the key type
        // BEFORE attempting cryptographic verification
        <span class="cov6" title="42">if err := validateAlgorithmKeyMatch(sigAlgOID, pub, hashAlg); err != nil </span><span class="cov4" title="8">{
                return err
        }</span>

        <span class="cov6" title="34">switch pubKey := pub.(type) </span>{
        case *ecdsa.PublicKey:<span class="cov5" title="20">
                digest, err := computeDigest(data, hashAlg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="20">if !ecdsa.VerifyASN1(pubKey, digest, signature) </span><span class="cov1" title="1">{
                        return fmt.Errorf("ECDSA signature verification failed")
                }</span>
                <span class="cov5" title="19">return nil</span>

        case ed25519.PublicKey:<span class="cov3" title="5">
                if !ed25519.Verify(pubKey, data, signature) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Ed25519 signature verification failed")
                }</span>
                <span class="cov3" title="5">return nil</span>

        case ed448.PublicKey:<span class="cov0" title="0">
                // Ed448 pure mode verification with empty context (RFC 8419)
                if !ed448.Verify(pubKey, data, signature, "") </span><span class="cov0" title="0">{
                        return fmt.Errorf("Ed448 signature verification failed")
                }</span>
                <span class="cov0" title="0">return nil</span>

        case *rsa.PublicKey:<span class="cov4" title="9">
                digest, err := computeDigest(data, hashAlg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="9">if err := rsa.VerifyPKCS1v15(pubKey, hashAlg, digest, signature); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("RSA signature verification failed: %w", err)
                }</span>
                <span class="cov4" title="9">return nil</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported public key type for classical verification: %T", pub)</span>
        }
}

// verifyPQCSignature attempts to verify a PQC signature.
func verifyPQCSignature(data, signature []byte, cert *x509.Certificate, sigAlgOID asn1.ObjectIdentifier) error <span class="cov7" title="58">{
        // Check for Composite signature (ML-DSA + ECDSA)
        if x509util.IsCompositeOID(sigAlgOID) </span><span class="cov0" title="0">{
                return ca.VerifyCompositeSignature(data, signature, cert, sigAlgOID)
        }</span>

        // First, try to use Go's parsed public key (if available)
        <span class="cov7" title="58">if cert.PublicKey != nil </span><span class="cov0" title="0">{
                if verifier, ok := cert.PublicKey.(interface {
                        Verify(message, sig []byte) bool
                }); ok </span><span class="cov0" title="0">{
                        if !verifier.Verify(data, signature) </span><span class="cov0" title="0">{
                                return fmt.Errorf("ML-DSA signature verification failed")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Go couldn't parse the PQC public key - extract it from RawSubjectPublicKeyInfo
        <span class="cov7" title="58">pubKey, alg, err := extractPQCPublicKey(cert)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract PQC public key: %w", err)
        }</span>

        // Verify the signature using our crypto package
        <span class="cov7" title="58">if err := pkicrypto.VerifySignature(pubKey, alg, data, signature); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("PQC signature verification failed: %w", err)
        }</span>

        <span class="cov7" title="57">return nil</span>
}

// extractPQCPublicKey extracts a PQC public key from a certificate's RawSubjectPublicKeyInfo.
func extractPQCPublicKey(cert *x509.Certificate) (crypto.PublicKey, pkicrypto.AlgorithmID, error) <span class="cov7" title="58">{
        raw := cert.RawSubjectPublicKeyInfo
        var spki struct {
                Algorithm pkix.AlgorithmIdentifier
                PublicKey asn1.BitString
        }
        if _, err := asn1.Unmarshal(raw, &amp;spki); err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to parse SPKI: %w", err)
        }</span>

        // Determine algorithm from OID
        <span class="cov7" title="58">alg := pkicrypto.AlgorithmFromOID(spki.Algorithm.Algorithm)
        if alg == pkicrypto.AlgUnknown </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("unknown algorithm OID: %v", spki.Algorithm.Algorithm)
        }</span>

        // Parse the public key
        <span class="cov7" title="58">pubKey, err := pkicrypto.ParsePublicKey(alg, spki.PublicKey.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        <span class="cov7" title="58">return pubKey, alg, nil</span>
}

// extractEd448PublicKey extracts an Ed448 public key from a certificate's RawSubjectPublicKeyInfo.
// This is needed because Go's x509 library doesn't support Ed448 natively.
func extractEd448PublicKey(cert *x509.Certificate) (ed448.PublicKey, error) <span class="cov4" title="8">{
        raw := cert.RawSubjectPublicKeyInfo
        var spki struct {
                Algorithm pkix.AlgorithmIdentifier
                PublicKey asn1.BitString
        }
        if _, err := asn1.Unmarshal(raw, &amp;spki); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse SPKI: %w", err)
        }</span>

        // Verify the algorithm OID is Ed448
        <span class="cov4" title="8">if !spki.Algorithm.Algorithm.Equal(OIDEd448) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected Ed448 OID, got %v", spki.Algorithm.Algorithm)
        }</span>

        // Ed448 public key should be 57 bytes
        <span class="cov4" title="8">pubBytes := spki.PublicKey.Bytes
        if len(pubBytes) != ed448.PublicKeySize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid Ed448 public key size: %d, expected %d", len(pubBytes), ed448.PublicKeySize)
        }</span>

        <span class="cov4" title="8">return ed448.PublicKey(pubBytes), nil</span>
}

// oidToHash converts a hash algorithm OID to crypto.Hash.
func oidToHash(oid asn1.ObjectIdentifier) (crypto.Hash, error) <span class="cov9" title="233">{
        switch </span>{
        case oid.Equal(OIDSHA256):<span class="cov8" title="132">
                return crypto.SHA256, nil</span>
        case oid.Equal(OIDSHA384):<span class="cov6" title="27">
                return crypto.SHA384, nil</span>
        case oid.Equal(OIDSHA512):<span class="cov7" title="61">
                return crypto.SHA512, nil</span>
        case oid.Equal(OIDSHA3_256):<span class="cov3" title="4">
                return crypto.SHA3_256, nil</span>
        case oid.Equal(OIDSHA3_384):<span class="cov3" title="4">
                return crypto.SHA3_384, nil</span>
        case oid.Equal(OIDSHA3_512):<span class="cov3" title="4">
                return crypto.SHA3_512, nil</span>
        default:<span class="cov1" title="1">
                return 0, fmt.Errorf("unsupported hash algorithm: %v", oid)</span>
        }
}

// Note: computeDigest is defined in signer.go and shared across the package

// extractSigningTime extracts the signing time from signed attributes.
func extractSigningTime(attrs []Attribute) time.Time <span class="cov8" title="106">{
        for _, attr := range attrs </span><span class="cov9" title="208">{
                if attr.Type.Equal(OIDSigningTime) &amp;&amp; len(attr.Values) &gt; 0 </span><span class="cov8" title="104">{
                        var t time.Time
                        _, err := asn1.Unmarshal(attr.Values[0].FullBytes, &amp;t)
                        if err == nil </span><span class="cov8" title="104">{
                                return t
                        }</span>
                }
        }
        <span class="cov2" title="2">return time.Time{}</span>
}

// ParseCertificates exports the certificate parsing for external use.
func ParseCertificates(raw []byte) ([]*x509.Certificate, error) <span class="cov2" title="3">{
        return parseCertificates(raw)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
